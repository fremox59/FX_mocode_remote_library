[{"_id":"Fremox-1568287603039","name":"Fremox","type":"expression","creation_date":1568287603041,"expressions":[{"_id":"2D-auto-orientation-1568287673597","code":"L = _ layer: auto Orient Layer: create _;\r\nu = L.toWorldVec([1, 0]);\r\nradiansToDegrees(Math.atan2(u[1], u[0]));","name":"2D auto orientation","documentation":"Permet de retrouver l'angle de `rotation` d'un calque appelé \"auto Oriented Layer\" (dans les effets) censé être animé sur sa position et sur lequel on a coché l'option \"Orienté sur le chemin\" (dans \"Géométrie > Orientation automatique). Cette fonction est ainsi utile uniquement dans ce cas précis, car avec cette fonction d'orientation automatique, la \"vraie propriété de `rotation`\" (dans Transformations) reste inchangée et est impossible à analyser autrement.\n\nInitial expression by **DAN EBBERTS**\n\n<http://motionscript.com/mastering-expressions/lst-2d-auto-orient.html>","property_types":["1d"],"tags":["vector","orientation","rotation","cible","target","DAN EBBERTS"],"last_update":1572454692163},{"_id":"3D-Layer-Verso-flip--Scale-1570720323994","code":"if (toCompVec([0, 0, 1])[2] > 0) {\r\n\tvalue;\r\n} else {\r\n\t[-value[0], value[1], value[2]];\r\n}","name":"3D Layer Verso flip (Scale)","documentation":"Permet de faire une symétrie horizontale automatiquement lorsqu'on voit le voit le \"verso\" d'un calque 3D afin que son contenu (image, texte...) soit lisible dans le bon sens.\n\nInitial expression by **ADOBE**\n\n<https://helpx.adobe.com/fr/after-effects/using/expression-examples.html>","property_types":["2d"],"tags":["flip","symmetry","scale","3D","facing","verso","ADOBE"],"last_update":1570721341645},{"_id":"3D-Layer-Verso-invisible-1570720598779","code":"c = _ checkbox: invert visible side: create _;\r\nif (c * toCompVec([0, 0, 1])[2] > 0) {\r\n\tvalue;\r\n} else {\r\n\t0;\r\n}","name":"3D Layer Verso invisible","documentation":"Permet de faire disparaître un calque 3D en mettant automatiquement l'opacité à 0 quand la caméra 3D d'AE \"voit\" l'envers du calque.\n\nPeut-être inversée en cochant la case `invert visible side` au cas où on voudrait plutôt voir le verso du calque.\n\nInitial expression by **DAN EBBERTS**\n\n<http://www.motionscript.com/design-guide/invisible-facing-away.html>\n\n\n","property_types":["1d"],"tags":["invisible","facing","recto","verso","3D","opacity","DAN EBBERTS"],"last_update":1590419065500},{"_id":"Adapt-multiple-Scales-1570721485057","code":"A = _ slider: Surface: create _;\r\nC = _ slider: Correction: create _;\r\nR = width / height;\r\nrect = R;\r\nif (R > 1) {\r\n\trect = 1 / R\r\n}\r\n\r\ncorrection = linear(rect, 0, 1, 1 + C / 100, 1);\r\n\r\nW = Math.pow(A * R, .5);\r\ns = (100 / width) * W *\r\n\tcorrection;\r\n\r\n[s, s]","name":"Adapt multiple Scales","documentation":"Permet d'uniformiser l'échelle de multiples calques pour que ces derniers occupent \"visuellement\" la même aire en pixels (très utile pour uniformiser de multiples logos ou photos - parfois verticaux, horizontaux ou carrés - dans une même composition !).\n\nL'idéal serait ensuite de lier les 2 effets `Surface` et `Correction` à un un calque externe - un Nul appelé \"CTRL\" par exemple - qui aurait ces mêmes 2 sliders, pour pouvoir adapter tous les layers en même temps sans avoir à le faire pour chacun.\n\n\nInitial expression by **MATHIEU TOBERT (aka Freelance Saucisse)**\n\n<http://lefreelancesaucisse.blogspot.com/2009/01/diaporama-alpha-turbo-prime-2.html>","property_types":["2d"],"tags":["auto","size","area","aire","surface","multiple","scale","freelance","saucisse","mathieu","robert"],"last_update":1570721775996},{"_id":"Advanced-text-expression-selector-1570721818531","code":"//Luigimx_textAnimator.expSelector_v01.29\r\nvar sourceTxt = text.sourceText;\r\nvar animator = thisProperty.propertyGroup(3);\r\nvar animatorName = animator.name;\r\nvar selector = thisProperty.propertyGroup(1);\r\nvar result = 0;\r\n\r\n//[ 0, X, Y ] == All off\r\nif (thisLayer.active && animator.active && selector.active) {\r\n\tvar valX = _ checkbox: activate Selector: create _;\r\n\tvar valY = Math.round(_ slider: instances Amount: create _);\r\n\tvar valZ = Math.round(_ slider: selectorName Slicer: create _);\r\n\r\n\tif (valX == 1) {\r\n\t\tvar basedOn = selector.basedOn;\r\n\r\n\t\t//Selector is NOT based on Lines\r\n\t\tif (basedOn.value != 4) {\r\n\t\t\tvar charactersRE = /\\r?\\n|\\r/g;\r\n\t\t\tvar wordsRE = /\\s/g;\r\n\t\t\tvar noSep = \"\";\r\n\t\t\tvar vSep = \"\\v\";\r\n\t\t\tvar animatorRE = charactersRE;\r\n\t\t\tvar animatorSep = noSep;\r\n\t\t\tvar sourceRE, sourceSeparator;\r\n\r\n\t\t\tswitch (basedOn.value) {\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tsourceRE = charactersRE;\r\n\t\t\t\t\tsourceSeparator = noSep;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tsourceRE = wordsRE;\r\n\t\t\t\t\tsourceSeparator = noSep;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 3:\r\n\t\t\t\t\tanimatorRE = wordsRE;\r\n\t\t\t\t\tanimatorSep = vSep;\r\n\t\t\t\t\tsourceRE = wordsRE;\r\n\t\t\t\t\tsourceSeparator = vSep;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tvar sourceTxtFixed = sourceTxt.replace(sourceRE, sourceSeparator);\r\n\t\t\tvar sourceArr = sourceTxtFixed.split(sourceSeparator);\r\n\t\t\tvar sourceLen = sourceArr.length;\r\n\t\t\tvar animatorNameFixed = animatorName.replace(animatorRE, animatorSep);\r\n\t\t\tvar animatorArr = (animatorNameFixed.length > 1) ? animatorNameFixed.split(animatorSep) : [animatorNameFixed];\r\n\t\t\tvar animatorLen = animatorArr.length;\r\n\r\n\t\t\tfunction escapeRegExp(stringToGoIntoTheRegex) {\r\n\t\t\t\treturn stringToGoIntoTheRegex.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\r\n\t\t\t}\r\n\r\n\t\t\tvar indicesArr = [];\r\n\r\n\t\t\t//Find pattern occurrences in source text and store inside array\r\n\t\t\tfunction findIndicesInSource(str) {\r\n\t\t\t\tvar patternIndices = [];\r\n\t\t\t\tvar patternRE = new RegExp(escapeRegExp(str), 'g');\r\n\t\t\t\tvar patternMatches;\r\n\t\t\t\twhile ((patternMatches = patternRE.exec(sourceTxtFixed))) {\r\n\t\t\t\t\tpatternIndices.push(patternMatches.index);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (basedOn.value == 3 && patternIndices.length > 0) {\r\n\t\t\t\t\tvar sourceObj = {};\r\n\t\t\t\t\tvar p = 0;\r\n\t\t\t\t\twhile (p < sourceLen) {\r\n\t\t\t\t\t\tsourceObj[sourceArr[p]] = (!(sourceArr[p] in sourceObj)) ? [] : sourceObj[sourceArr[p]];\r\n\t\t\t\t\t\tsourceObj[sourceArr[p]].push(p);\r\n\t\t\t\t\t\tp++\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tpatternIndices = sourceObj[str];\r\n\t\t\t\t\t} catch (err) {\r\n\t\t\t\t\t\tpatternIndices = [sourceLen];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn patternIndices;\r\n\t\t\t}\r\n\r\n\t\t\tindicesArr = findIndicesInSource(animatorNameFixed);\r\n\r\n\t\t\tvar itemZ = animatorNameFixed;\r\n\t\t\tif (valZ > 0) {\r\n\t\t\t\tvar arrZ = animatorArr;\r\n\r\n\t\t\t\t// Z value will represent the index of a character or word item from the animator name\r\n\t\t\t\tif (arrZ.length > 0) {\r\n\t\t\t\t\tif ((valZ - 1) < arrZ.length) {\r\n\t\t\t\t\t\titemZ = arrZ[valZ - 1];\r\n\t\t\t\t\t\tif (animatorLen > 1 && basedOn.value != 2) {\r\n\t\t\t\t\t\t\tindicesArr = findIndicesInSource(itemZ);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// } else {\r\n\t\t\t\t\t\t// itemZ = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar itemY = sourceLen;\r\n\t\t\tif (valY > 0) {\r\n\t\t\t\tvar arrY = indicesArr;\r\n\r\n\t\t\t\t// Y value will represent the index of the occurence\r\n\t\t\t\tif ((arrY.length > 0) && ((valY - 1) < arrY.length)) {\r\n\t\t\t\t\titemY = arrY[valY - 1];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//Animator name has more than one character\r\n\t\t\tif (animatorLen > 1) {\r\n\r\n\t\t\t\t//Selector IS based on Characters Excluding Spaces\r\n\t\t\t\tif (basedOn.value == 2) {\r\n\r\n\t\t\t\t\t//Create object that contains pattern indexes\r\n\t\t\t\t\tvar patternObj = function() {\r\n\t\t\t\t\t\tvar indicesLen = indicesArr.length\r\n\t\t\t\t\t\tvar chars, h, m, n, idx, patternObj = {};\r\n\t\t\t\t\t\tif (valZ > 0) {\r\n\t\t\t\t\t\t\tchars = clamp(valZ, 1, animatorLen);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tchars = animatorLen;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\th = 0;\r\n\t\t\t\t\t\twhile (h < (indicesLen * chars)) {\r\n\t\t\t\t\t\t\tn = 0;\r\n\t\t\t\t\t\t\twhile (n < indicesLen) {\r\n\t\t\t\t\t\t\t\tm = 0;\r\n\t\t\t\t\t\t\t\twhile (m < chars) {\r\n\t\t\t\t\t\t\t\t\tidx = indicesArr[n] + m;\r\n\t\t\t\t\t\t\t\t\tpatternObj[idx] = h;\r\n\t\t\t\t\t\t\t\t\tm++;\r\n\t\t\t\t\t\t\t\t\th++;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tn++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn patternObj;\r\n\t\t\t\t\t}();\r\n\r\n\t\t\t\t\t//Change sourceArr so it will only match the entire pattern\r\n\t\t\t\t\tvar i = 0;\r\n\t\t\t\t\twhile (i < sourceLen) {\r\n\t\t\t\t\t\tif (!(i in patternObj)) {\r\n\t\t\t\t\t\t\tsourceArr[i] = vSep;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ti++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (valY < 1) {\r\n\t\t\t\t\tif (valZ < 1) {\r\n\t\t\t\t\t\t//[ 1, 0, 0 ] == All items, all occurrences\r\n\t\t\t\t\t\tvar animatorObj = {};\r\n\t\t\t\t\t\tfor (var j = 0; j < animatorLen; j++) {\r\n\t\t\t\t\t\t\tanimatorObj[animatorArr[j]] = (!(animatorArr[j] in animatorObj)) ? [] : animatorObj[animatorArr[j]];\r\n\t\t\t\t\t\t\tanimatorObj[animatorArr[j]].push(j);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tresult = (sourceArr[textIndex - 1] in animatorObj) ? 100 : result;\r\n\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (basedOn.value != 2) {\r\n\t\t\t\t\t\t\t//[ 1, 0, z ] == All occurrences, Z item\r\n\t\t\t\t\t\t\tresult = (itemZ == sourceArr[textIndex - 1]) ? 100 : result;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t//[ 1, 0, z ] == All pattern occurrences, up to Z character\r\n\t\t\t\t\t\t\tresult = ((textIndex - 1) in patternObj) ? 100 : result;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif (valZ < 1) {\r\n\r\n\t\t\t\t\t\tif (basedOn.value != 2) {\r\n\t\t\t\t\t\t\t//[ 1, y, 0 ] == Y occurrence, all items\r\n\t\t\t\t\t\t\tresult = ((itemY <= (textIndex - 1)) && ((textIndex - 1) <= (itemY + animatorLen - 1))) ? 100 : result;\r\n\r\n\t\t\t\t\t\t\t//[ 1, y, 0 ] == Y occurrence of the whole pattern\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tresult = ((itemY <= (textIndex - 1)) && ((textIndex - 1) <= (itemY + animatorLen - 1))) ? 100 : result;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t//[ 1, y, z ] == Y occurrence, Z item\r\n\t\t\t\t\t\tif (basedOn.value != 2) {\r\n\t\t\t\t\t\t\tresult = (itemY == (textIndex - 1)) ? 100 : result;\r\n\r\n\t\t\t\t\t\t\t//[ 1, y, z ] == Y occurrence of the pattern item, up to Z character\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tresult = ((itemY <= (textIndex - 1)) && ((textIndex - 1) <= (itemY + valZ - 1)) && ((valZ - 1) < animatorLen)) ? 100 : result;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\t\t\t\t//Animator name has only one character\r\n\t\t\t\tif (valZ < 1) {\r\n\t\t\t\t\tif (valY < 1) {\r\n\t\t\t\t\t\t//[ 1, 0, 0 ] == All occurrences of character\r\n\t\t\t\t\t\tresult = (itemZ == sourceArr[textIndex - 1]) ? 100 : result;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t//[ 1, 1, 0 ] == Y occurrence of character\r\n\t\t\t\t\t\tresult = (itemY == (textIndex - 1)) ? 100 : result;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\t//Selector IS based on Lines\r\n\t\t\tif (valY > 0) {\r\n\t\t\t\tif (valY >= valZ) {\r\n\t\t\t\t\tresult = (valY == textIndex) ? 100 : result;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult = (valY <= textIndex) && (valZ >= textIndex) ? 100 : result;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nresult *= selectorValue","name":"Advanced text selector","documentation":"Une fois l'expression appliquée à la propriété `Valeur` (=`Amount` en anglais) d'un selecteur d'expression dans un calque de texte, on va pouvoir affecter les propriétés de l'animator voulues (RBG color, positions, scale, tracking...) aux lettres, mots et lignes de notre choix très précisément, juste en renommant le nom de l'animator (son groupe complet) par la lettre ou l'ensemble de lettre (voire mots) que l'on souhaite chercher et mettre en valeur (par exemple en renommant l'animator \"Yes\", il retrouverait automatiquement toutes les occurences du mot \"Yes\" dans le source Text) !\n\nNe pas oublier d'activer le selecteur en cochant la case `activate Selector`\n\nIl suffit alors de choisir soit \"Caractères, Mots ou Lignes\" comme d'habitude dans l'animator, puis de jouer avec les sliders `instances Amount` pour sélectionner le numéro d'instance à utiliser (si on laisse à 0 comme valeur dans ce slider alors TOUTES les instances sont gardées), et le slider `selectorName Slicer` pour décider de ne sélectionner qu'une seule lettre dans l'animator name (si on laisse 0 comme par défaut, alors on utilise tout le name).\n\n\nInitial expression by **LUIS MARTINEZ (aka Luigimix)**\n\n<https://www.youtube.com/watch?v=wgiaNEQit3g>","tags":["text","amount","selector","animator","words","sort","lines","character","name","rege","luigimix","Luis","martinez"],"last_update":1591369575524},{"_id":"Angular-controls-1570691493023","code":"var a = _ angle: angleControl: create _;\r\nvar d = _ slider: strength: create _;\r\n\r\nx = Math.cos(degreesToRadians(a));\r\ny = Math.sin(degreesToRadians(a));\r\nvalue + [x * d, y * d];","name":"Angular controls","documentation":"Permet de contraindre la direction de certains effets (comme une position par exemple) selon un angle précis (45 pour faire du \"long shadow\" par exemple) via le `angleControl` avec une intensité combinée sur les 2 axes dépendante du paramètre `strength`.\n\nInitial expression by **WORKBENCH**\n\n<http://workbench.tv/tutorials/2017-09-08_AngularControls/>\n\n","property_types":["2d"],"tags":["diagonal","angle","constrain","shadow","long","isometric","WORKBENCH"],"last_update":1570721967828},{"_id":"Animation-Model-1572877843506","code":"var target = _ layer: Model layer: create _;\r\nvar e = target.scale; //replace scale by your own property\r\ne.valueAtTime(time - inPoint + target.inPoint)","name":"Animation Model (scale)","documentation":"Permet de baser l'animation de la propriété à laquelle est appliquée cette expression (ici l'échelle), sur l'animation d'un calque \"Model\" choisi dans la liste déroulante de l'effet.\n\nEn bougeant le `inPoint` des calques qui ont cette expression dans la timeline (NB : on peut utiliser un script comme \"Sequence Layers\" ou \"Rift\" quand il y en a beaucoup), l'animation se jouera de manière décalée sur le même modèle que ce calque référencé !\n\nInitial Expression by **Matthieu Robert (aka Freelance Saucisse)**\n\nhttp://lefreelancesaucisse.blogspot.com/2010/02/animation-modele.html","tags":["freelance","saucisse","matthieu","robert","model","offset","sequence","time remap","trigger"],"last_update":1572878636680},{"_id":"Animation-Remapper-1572878517808","code":"var p = _ slider: Anim Remapper: create _;\r\n\r\nvar n = numKeys;\r\nvar start = key(1).time;\r\nvar end = key(n).time;\r\nvar p = linear(p, 0, 100, start, end);\r\n\r\nvalueAtTime(p)","name":"Animation Remapper","documentation":"Permet de faire un \"remappage temporel de clés\" (même si la propriété contient des centaines de clés) à l'aide d'un simple curseur qu'on peut alors animer de 0 à 100%.\n\nInitial Expression by **Matthieu Robert (aka Freelance Saucisse)**\n\nhttp://lefreelancesaucisse.blogspot.com/2010/01/remappage-temporel-de-clef.html","tags":["matthieu","robert","freelance","saucisse","time remap","morpher","range","converter","mapper","speed"],"last_update":1572878747750},{"_id":"Auto-Anim-by-layer-inOutPoint-1572878766198","code":"var maxV = _ slider: valueToReach: create _;\r\nvar transition = _ slider: transitionTime: create _; // transition time in frames\r\nvar easingInt = _ slider: easingIntensity: create _;\r\n\r\nif (easingInt % 2 == 0) {\r\n\teasingInt = easingInt - 1;\r\n} else {\r\n\teasingInt = easingInt;\r\n}\r\n\r\nvar tSecs = transition / (1 / thisComp.frameDuration); // convert to seconds\r\n\r\nfunction myCustomEaseIn(t, d) {\r\n\treturn Math.pow(t / d, easingInt);\r\n}\r\n\r\nfunction myCustomEaseOut(t, d) {\r\n\treturn 1 - Math.pow(1 - (t / d), easingInt);\r\n}\r\n\r\nclamp(myCustomEaseOut(time - inPoint, tSecs) * maxV, 0, maxV) - clamp(myCustomEaseIn((time - outPoint + tSecs), tSecs) * maxV, 0, maxV);","name":"Auto Anim by inOutPoint1","documentation":"Permet d'animer automatiquement une valeur à une dimension (par défaut un pourcentage mais l'on peut changer la valeur 100 par défaut grâce au slider `valueToReach`) en fonction du point d'entrée (`inPoint`) et de sortie (`outPoint`) du calque sur lequel l'expression est appliquée.\n\nLa durée de la transition pour le In et le Out est alors déterminée par le nombre d'images (frames) dans le curseur `transitionTime` (15 par défaut : si on augmente l'animation est plus lente ; si on réduit elle sera plus courte).\n\nLa force d'amortissement (easing) est déterminée par le chiffre entré dans `easingIntensity` sachant que seuls les chiffres impairs (1, 3, 5 , 7, 9...) seront réellement pris en compte. Une valeur de 1 correspond à aucun amorti (animation linéaire classique d'AfterEffects), 3 correspond au mode \"cubique\" (comme les clés lissées d'AfterEffects), 5 à du \"cintiq\" et \"11\" à de l'exponentiel (effet d'inertie très marqué) \n\nInitial expression by **Matthieu Fremeaux (aka Fremox)**","property_types":["1d"],"tags":["fremox","matthieu","fremeaux","auto","animate","out","inPoint","easing","velocity","expo"],"last_update":1572882453415},{"_id":"Auto-Anim-by-layer-inOutPoint-2-1572879400231","code":"var maxV = _ point: valueToReach2: create _;\r\nvar transition = _ slider: transitionTime: create _; // transition time in frames\r\nvar easingInt = _ slider: easingIntensity: create _;\r\n\r\nif (easingInt % 2 == 0) {\r\n\teasingInt = easingInt - 1;\r\n} else {\r\n\teasingInt = easingInt;\r\n}\r\n\r\nvar tSecs = transition / (1 / thisComp.frameDuration); // convert to seconds\r\n\r\nfunction myCustomEaseIn(t, d) {\r\n\treturn Math.pow(t / d, easingInt);\r\n}\r\n\r\nfunction myCustomEaseOut(t, d) {\r\n\treturn 1 - Math.pow(1 - (t / d), easingInt);\r\n}\r\n\r\nclamp(myCustomEaseOut(time - inPoint, tSecs) * maxV, 0, maxV) - clamp(myCustomEaseIn((time - outPoint + tSecs), tSecs) * maxV, 0, maxV);","name":"Auto Anim by inOutPoint2","documentation":"Permet d'animer automatiquement une valeur à 2 dimensions grâce au slider `valueToReach2` en fonction du point d'entrée (`inPoint`) et de sortie (`outPoint`) du calque sur lequel l'expression est appliquée.\n\nLa durée de la transition pour le In et le Out est alors déterminée par le nombre d'images (frames) dans le curseur `transitionTime` (15 par défaut : si on augmente l'animation est plus lente ; si on réduit elle sera plus courte).\n\nLa force d'amortissement (easing) est déterminée par le chiffre entré dans `easingIntensity` sachant que seuls les chiffres impairs (1, 3, 5 , 7, 9...) seront réellement pris en compte. Une valeur de 1 correspond à aucun amorti (animation linéaire classique d'AfterEffects), 3 correspond au mode \"cubique\" (comme les clés lissées d'AfterEffects), 5 à du \"cintiq\" et \"11\" à de l'exponentiel (effet d'inertie très marqué) \n\nInitial expression by **Matthieu Fremeaux (aka Fremox)**","property_types":["2d","2d_spatial"],"tags":["matthieu","fremeaux","fremox","easing","auto","animate","inPoint","out","expo","velocity"],"last_update":1572882448432},{"_id":"Auto-Anim-by-layer-inPoint-1-1572880099333","code":"var maxV = _ slider: valueToReach IN: create _;\r\nvar transition = _ slider: transitionTime: create _; // transition time in frames\r\nvar easingInt = _ slider: easingIntensity: create _;\r\n\r\nif (easingInt % 2 == 0) {\r\n\teasingInt = easingInt - 1;\r\n} else {\r\n\teasingInt = easingInt;\r\n}\r\n\r\ntSecs = transition / (1 / thisComp.frameDuration); // convert to seconds\r\n\r\nfunction myCustomEaseIn(t, d) {\r\n\treturn Math.pow(t / d, easingInt);\r\n}\r\n\r\nfunction myCustomEaseOut(t, d) {\r\n\treturn 1 - Math.pow(1 - (t / d), easingInt);\r\n}\r\n\r\nclamp(myCustomEaseOut(time - inPoint, tSecs) * maxV, 0, maxV)","name":"Auto Anim by inPoint1","documentation":"Permet d'animer automatiquement une valeur à une dimension (par défaut un pourcentage mais l'on peut changer la valeur 100 par défaut grâce au slider `valueToReach IN`) en fonction du point d'entrée (`inPoint`) du calque sur lequel l'expression est appliquée.\n\nLa durée de la transition pour le IN est alors déterminée par le nombre d'images (frames) dans le slider `transitionTime` (15 par défaut : si on augmente l'animation est plus lente ; si on réduit elle sera plus courte).\n\nLa force d'amortissement (easing) est déterminée par le chiffre entré dans `easingIntensity` sachant que seuls les chiffres impairs (1, 3, 5 , 7, 9...) seront réellement pris en compte. Une valeur de 1 correspond à aucun amorti (animation linéaire classique d'AfterEffects), 3 correspond au mode \"cubique\" (comme les clés lissées d'AfterEffects), 5 à du \"cintiq\" et \"11\" à de l'exponentiel (effet d'inertie très marqué) \n\ninitial expression by **Matthieu Fremeaux (aka Fremox)**","property_types":["1d"],"tags":["matthieu","fremeaux","fremox","auto","animate","easing","expo","inPoint","velocity"],"last_update":1572882461415},{"_id":"Auto-Anim-by-layer-inPoint-2-1572880345944","code":"var maxV = _ point: valueToReach IN: create _;\r\nvar transition = _ slider: transitionTime: create _; // transition time in frames\r\nvar easingInt = _ slider: easingIntensity: create _;\r\n\r\nif (easingInt % 2 == 0) {\r\n\teasingInt = easingInt - 1;\r\n} else {\r\n\teasingInt = easingInt;\r\n}\r\n\r\ntSecs = transition / (1 / thisComp.frameDuration); // convert to seconds\r\n\r\nfunction myCustomEaseIn(t, d) {\r\n\treturn Math.pow(t / d, easingInt);\r\n}\r\n\r\nfunction myCustomEaseOut(t, d) {\r\n\treturn 1 - Math.pow(1 - (t / d), easingInt);\r\n}\r\n\r\nclamp(myCustomEaseOut(time - inPoint, tSecs) * maxV, 0, maxV)","name":"Auto Anim by inPoint2","documentation":"Permet d'animer automatiquement une valeur à 2 dimensions grâce au slider `valueToReach IN`, en fonction du point d'entrée (`inPoint`) du calque sur lequel l'expression est appliquée.\n\nLa durée de la transition pour le IN est alors déterminée par le nombre d'images (frames) dans le slider `transitionTime` (15 par défaut : si on augmente l'animation est plus lente ; si on réduit elle sera plus courte).\n\nLa force d'amortissement (easing) est déterminée par le chiffre entré dans `easingIntensity` sachant que seuls les chiffres impairs (1, 3, 5 , 7, 9...) seront réellement pris en compte. Une valeur de 1 correspond à aucun amorti (animation linéaire classique d'AfterEffects), 3 correspond au mode \"cubique\" (comme les clés lissées d'AfterEffects), 5 à du \"cintiq\" et \"11\" à de l'exponentiel (effet d'inertie très marqué) \n\ninitial expression by **Matthieu Fremeaux (aka Fremox)**","property_types":["2d","2d_spatial"],"tags":["matthieu","fremeaux","fremox","easing","expo","velocity","auto","animate","inPoint"],"last_update":1572882468568},{"_id":"Auto-Anim-by-layer-ouPoint-1-1572880975733","code":"var maxV = _ slider: valueToReach OUT: create _;\r\nvar transition = _ slider: transitionTime: create _; // transition time in frames\r\nvar easingInt = _ slider: easingIntensity: create _;\r\n\r\nif (easingInt % 2 == 0) {\r\n\teasingInt = easingInt - 1;\r\n} else {\r\n\teasingInt = easingInt;\r\n}\r\n\r\ntSecs = transition / (1 / thisComp.frameDuration); // convert to seconds\r\n\r\nfunction myCustomEaseIn(t, d) {\r\n\treturn Math.pow(t / d, easingInt);\r\n}\r\n\r\nfunction myCustomEaseOut(t, d) {\r\n\treturn 1 - Math.pow(1 - (t / d), easingInt);\r\n}\r\n\r\nmaxV - clamp(myCustomEaseIn((time - outPoint + tSecs), tSecs) * maxV, 0, maxV)","name":"Auto Anim by outPoint 1","documentation":"Permet d'animer automatiquement une valeur à 1 dimension grâce au slider `valueToReach OUT`, en fonction du point de sortie (`outPoint`) du calque sur lequel l'expression est appliquée.\n\nLa durée de la transition pour le OUT est alors déterminée par le nombre d'images (frames) dans le slider `transitionTime` (15 par défaut : si on augmente l'animation est plus lente ; si on réduit elle sera plus courte).\n\nLa force d'amortissement (easing) est déterminée par le chiffre entré dans `easingIntensity` sachant que seuls les chiffres impairs (1, 3, 5 , 7, 9...) seront réellement pris en compte. Une valeur de 1 correspond à aucun amorti (animation linéaire classique d'AfterEffects), 3 correspond au mode \"cubique\" (comme les clés lissées d'AfterEffects), 5 à du \"cintiq\" et \"11\" à de l'exponentiel (effet d'inertie très marqué) \n\ninitial expression by **Matthieu Fremeaux (aka Fremox)**","property_types":["1d"],"tags":["velocity","auto","expo","animate","easing","matthieu","fremeaux","fremox","out"],"last_update":1572882478058},{"_id":"Auto-Anim-by-layer-outPoint-2-1572880731196","code":"var maxV = _ point: valueToReach OUT: create _;\r\nvar transition = _ slider: transitionTime: create _; // transition time in frames\r\nvar easingInt = _ slider: easingIntensity: create _;\r\n\r\nif (easingInt % 2 == 0) {\r\n\teasingInt = easingInt - 1;\r\n} else {\r\n\teasingInt = easingInt;\r\n}\r\n\r\ntSecs = transition / (1 / thisComp.frameDuration); // convert to seconds\r\n\r\nfunction myCustomEaseIn(t, d) {\r\n\treturn Math.pow(t / d, easingInt);\r\n}\r\n\r\nfunction myCustomEaseOut(t, d) {\r\n\treturn 1 - Math.pow(1 - (t / d), easingInt);\r\n}\r\n\r\nmaxV - clamp(myCustomEaseIn((time - outPoint + tSecs), tSecs) * maxV, 0, maxV)","name":"Auto Anim by outPoint2","documentation":"Permet d'animer automatiquement une valeur à 2 dimensions grâce au slider `valueToReach OUT`, en fonction du point de sortie (`outPoint`) du calque sur lequel l'expression est appliquée.\n\nLa durée de la transition pour le OUT est alors déterminée par le nombre d'images (frames) dans le slider `transitionTime` (15 par défaut : si on augmente l'animation est plus lente ; si on réduit elle sera plus courte).\n\nLa force d'amortissement (easing) est déterminée par le chiffre entré dans `easingIntensity` sachant que seuls les chiffres impairs (1, 3, 5 , 7, 9...) seront réellement pris en compte. Une valeur de 1 correspond à aucun amorti (animation linéaire classique d'AfterEffects), 3 correspond au mode \"cubique\" (comme les clés lissées d'AfterEffects), 5 à du \"cintiq\" et \"11\" à de l'exponentiel (effet d'inertie très marqué) \n\ninitial expression by **Matthieu Fremeaux (aka Fremox)**","property_types":["2d","2d_spatial"],"tags":["velocity","easing","expo","auto","animate","matthieu","fremeaux","fremox","out"],"last_update":1572882486688},{"_id":"Auto-Animator-by-Source-Text-keys-1572881148339","code":"var n = 0;\r\nif (text.sourceText.numKeys > 0) {\r\n\tn = text.sourceText.nearestKey(time).index;\r\n\tif (text.sourceText.key(n).time > time) {\r\n\t\tn--;\r\n\t}\r\n\tif (n == 0) {\r\n\t\tvalue;\r\n\t} else if (_ checkbox: Animate: create _ == 1) {\r\n\t\tt = time - text.sourceText.key(n).time;\r\n\t\tt * _ slider: AnimIN Speed: create _ * (1000 / text.sourceText.length);\r\n\t} else {\r\n\t\t100;\r\n\t}\r\n} else value;","name":"Auto Anim by sourceText","documentation":"Permet d'animer automatiquement un calque de texte en fonction des clés de son `sourceText`.\n\nFonctionne en mettant cette expression sur le paramètre `Début` d'un `sélecteur de plage` dans un calque de texte ;\n\nUne fois le `sourceText` animé avec des clés (forcément en mode maintien), l'expression anime le début de 0 à 100% à vitesse définie par le paramètre `AnimIN Speed` (généralement une valeur entre 1 et 6, comme 3 par exemple), à chaque fois que la tête de lecture arrive sur un nouveau texte source.\n\nPour pouvoir éditer les clés de texte facilement, une case `Animate` permet de désactiver temporairement l'animator sans avoir à désactiver l'expression ou l'animator en déroulant les groupes du calque texte (ne pas oublier de la recocher après avoir édité le texte ou juste après avoir appliqué ce preset avec MoCode !).\n\nTrès utile lorsqu'on a beaucoup de textes animés sur un même modèle, voire pour des sous-titrages avec animation !\n\ninitial expression by **Matthieu Fremeaux (aka Fremox)**","tags":["auto","keyframes","animator","text","source","selector","plage","writing"],"last_update":1572882521855},{"_id":"Auto-Center-Text-Vertically-1584452463573","code":"[0,thisLayer.sourceRectAtTime(time).height/2+thisLayer.sourceRectAtTime(time).top]","name":"Auto Center Text Vertically","documentation":"Cette expression - à appliquer sur le `point d'ancrage` - permet d'auto-centrer un calque de texte verticalement dans la composition (quel que soit le nombre de lignes du paragraphe, et la taille du texte)","tags":["text","anchor","center","vertically"],"last_update":1584452555895},{"_id":"Auto-Fade-by-3D-camera-distance-1572881752402","code":"var startFade = _slider: startFade: create_;\r\nvar endFade = _slider: endFade: create_;\r\nvar cam = thisComp.activeCamera.toWorld([0, 0, 0]);\r\nvar pos = toWorld(anchorPoint);\r\nvar dst = length(cam, pos);\r\nlinear(dst, startFade, endFade, 100, 0)","name":"Auto Fade by cam distance","documentation":"Permet de faire apparaître un `calque 3D` progressivement en fonction de sa proximité avec la caméra (au plus le calque est loin, au moins il est visible, au plus il est prêt, au plus il sera visible, avec évidement des limites à 0 et 100% puisque l'expression est censée être appliquée sur la propriété `opacité` du calque).\n\ninitial expression by **Animoplex**\n\nhttps://www.youtube.com/watch?v=I-Acdl_l9G0&list=PLvr5U5ZSt6IzHyvSL9fo0M9NRPsTvra31&index=22","property_types":["1d"],"tags":["auto","fade","opacity","camera","fog","far","distance","lointain","3D"],"last_update":1572882719945},{"_id":"Auto-Fade-by-inOutPoint-1572882761974","code":"var transition = _ slider: transitionTime: create _; // transition time in frames\r\nif (marker.numKeys < 2) {\r\n\tvar tSecs = transition / (1 / thisComp.frameDuration); // convert to seconds\r\n\tlinear(time, inPoint, inPoint + tSecs, 0, 100) - linear(time, outPoint - tSecs, outPoint, 0, 100)\r\n} else {\r\n\tlinear(time, inPoint, marker.key(1).time, 0, 100) - linear(time, marker.key(2).time, outPoint, 0, 100)\r\n}","name":"Auto Fade by inOutPoint","documentation":"Permet d'animer automatiquement l' `opacité` (fondu) sur les calques concernés en se basant sur le `inPoint` (entrée) et le `outPoint` (sortie) de ces calques, pendant une durée de transition personnalisée via le curseur `transitionTime`.\n\nTrès pratique pour l'apparition de pictogrammes, de logos, de titrages multiples voire de diaporamas !\n\ninitial expression by **Harry Frank (aka Greymachine)**\n\nhttps://www.graymachine.com/top-5-effects-expressions/","property_types":["1d"],"tags":["auto","fade","fondu","diaporama","inPoint","out","opacity"],"last_update":1572882972741},{"_id":"Auto-Fade-with-obscuration-layer-1572883078233","code":"var target = _ layer: Obscuration layer: create _;\r\nvar samplePoint = _ point: samplePoint: create _;\r\nvar sampleRadius = _slider: sampleRadius: create_;\r\nvar valMin = _slider: segMin: create_;\r\nvar valMax = _slider: segMax: create_;\r\nvar alpha = target.sampleImage(samplePoint, [sampleRadius, sampleRadius])[3];\r\nlinear(alpha, 0, 1, valMax, valMin)","name":"Auto Fade by sampleImage","documentation":"Permet d'animer l'opacité ou l'intensité d'une propriété (l'intensité d'un halo lumineux par exemple) en fonction d'un point - appelé `samplePoint` - qui détecte la transparence `Alpha` d'un calque `Obscuration layer` (un PSD avec des nuages qui passent devant le halo du soleil par exemple), avec un rayon de recherche en pixels autour du point déterminé par le `sampleRadius` (au plus la valeur est grande, au plus la transition de la valeur sera douce et progressive)\n\ninitial expression by **DAN EBBERTS**\n\nhttp://www.motionscript.com/design-guide/obscuration.html\n","property_types":["1d"],"tags":["sampleImage","cloud","obscuration","opacity","transparent","alpha"],"last_update":1590414888107},{"_id":"Auto-Focus-1572883858089","code":"var target = thisComp.layer(1); //replace thisComp.layer(1) par your own layer to focus\r\nvar v1 = target.toWorld(target.anchorPoint) - toWorld([0, 0, 0]);\r\nvar v2 = toWorldVec([0, 0, 1]);\r\ndot(v1, v2)","name":"Auto Focus","documentation":"Expression à appliquer sur la propriété `Distance de mise au point\" d'une `caméra` lorsque son option `Profondeur de champ`est activée.\n\nPermet alors à cette caméra de toujours faire sa mise au point sur un `calque 3D` de notre choix (ici le 1er calque dans la composition, d'indice 1 : à remplacer dans l'expression par n'importe quel autre calque 3D dans la composition car il est impossible d'appliquer un effet option pour expression sur une caméra directement).\n\nAstuce : avec `Element 3D`, on peut générer une `3D position` via les `Utilities` ; permet donc de faire le focus très facilement sur un écran de device 3D ou toute autre surface, et même animée, la caméra restera avec une mise au point parfaite !","property_types":["1d"],"tags":["auto","focus","mise au point","camera","3D"],"last_update":1572884158116},{"_id":"Auto-Text-Scale-by-fixed-Width-Heigth-1591864429395","code":"var maxW = _ slider: Max Width: create _; //500 par exemple\r\nvar maxH = _ slider: Max Heigth: create _; //500 par exemple\r\nvar r = sourceRectAtTime(time);\r\nvar w = r.width;\r\nvar h = r.height;\r\nvar s = w/h > maxW/maxH ? maxW/w : maxH/h;\r\n[100, 100]*s;","name":"Auto Text Scale by fixed Width Heigth","documentation":"Permet d'adapter l' `échelle` d'un calque (plutôt de texte dans l'exemple initial mais peut servir aussi pour des calques de forme ou autres graphismes) automatiquement en fonction de dimensions fixes maximum (un curseur `Max Width` pour la largeur et un autre `Max Heigth` pour la hauteur).\n\nInitial expression by **NT Production**\n\nhttps://www.youtube.com/watch?time_continue=1291&v=dU272zx9vK8&feature=emb_logo\n\nbased on an original idea from **NSAKO**","property_types":[],"tags":["scale","resize","auto","sourceRect","text"],"last_update":1591864751092},{"_id":"Auto-Text-bloc-size--rectShape-1572886264679","code":"try {\r\n\t[parent.sourceRectAtTime(_slider: atTime: create_).width + effect(_slider: margin X: create_ * 2, parent.sourceRectAtTime(effect(\"atTime\")(1)).height + effect(_slider: margin Y: create_ * 2]\r\n\t\t}\r\n\t\tcatch (e) {\r\n\t\t\tvalue;\r\n\t\t};","name":"Text bloc Size (rectShape)","documentation":"À utiliser dans la `taille` d'un `rectangle en calque de forme layer`, parenté au calque de texte auquel on veut qu'il s'adapte. Suivant la \"justification\" voulue, il faut par contre bien placer le point d'ancrage de ce rectangle, en utilisant une expression comme :\n`[content(\"Tracé rectangulaire 1\").size[0]/2,0]`\ndans la position du tracé rectangulaire lui-même et non dans la position du calque (qui devrait être idéalement toujours à [0,0] de même que son point d'ancrage).\n\ninitial expression by **Matthieu Fremeaux (aka Fremox)**","tags":["text","synthe","bloc","sourceRect","taille","size","fremox"],"last_update":1572886856552},{"_id":"Auto-flip-at-mid-duration-1572884295537","code":"var C = _ checkbox: initialCase: create_;\r\n\r\nif (time >= ((outPoint + inPoint)) / 2) {\r\n\tC;\r\n} else {\r\n\t1 - C;\r\n}","name":"Auto flip at mid duration","documentation":"Permet de basculer/inverser la valeur d'une `case à cocher` automatiquement quand la tête de lecture passe exactement le milieu de la durée du calque (fait la moyenne entre le `inPoint` et le `outPoint` du calque).\n\nTrès pratique pour par exemple inverser le sens d'une transition créée automatiquement en fonction du `inPoint` et du `outPoint` d'un calque (avec les expressions `autoFade by inOutPoint` ou `auto Anim by layer inOutPoint` par exemple) !\n\ninitial expression by **Matthieu Fremeaux (aka Fremox)**\n","property_types":["1d"],"tags":["auto","animate","invert","flip","middle","center","duration","length","case","checkbox","inPoint","out"],"last_update":1572884591154},{"_id":"Auto-orient-flicking-issue-fix-1590418805726","code":"cornerEase = _ slider: cornerEase: create _; // sets the amount to look ahead and behind for gradual turns\r\npre = position.valueAtTime(time-thisComp.frameDuration*cornerEase);\r\npost = position.valueAtTime(time+thisComp.frameDuration*cornerEase);\r\ndelta = post-pre;\r\nif (delta[0] == 0 && delta[1] == 0) {\r\n  // if there is no change in vector maintain the current heading\r\n  rotation;\r\n} else {\r\n  // use the vector direction to orient. Flip the Y to account for cartesian Y being up and AE Y being down\r\n  radiansToDegrees(Math.atan2(delta[0],-delta[1]));\r\n}","name":"Auto-orient flicking issue fix","documentation":"Permet d'éviter les problème de \"flick\" de rotation quand on utilise l' `Auto-orient`.\n\nIl faut alors juste décocher l'option `Auto-orient` dans Géométrie, puis appliquer cette expression dans la propriété `Rotation` du calque 2D (qui lui est en mouvement avec des clés de position), et jouer avec le curseur \"cornerEase\" pour affiner les changements de direction soudains. \n\nUne fois l'expression calculée, l'idéal reste de \"baker\" cette expression (avec l'assistant d'images clés Ae), puis de supprimer la toute première et toute dernière keyframe qui posent généralement problème car il y a une \"saute\" dans la rotation ","property_types":["1d"],"tags":["smooth","flicker","clean"],"last_update":1590418901698},{"_id":"Auto-sized-dashed-circle-1572884621928","code":"var src = _slider: slices: create_;\r\nvar rad = _slider: diameter: create_ / 2;\r\nvar gap = _slider: gap: create_;\r\nvar seg = src <= 0 ? 1 : src;\r\n2 * Math.PI * rad / seg - gap","name":"Auto sized dashed circle","documentation":"Appliquée sur la propriété `Tiret` d'un contour sur une calque de forme contenant une ellipse (dont la taille est liée au curseur `diameter` avec le lasso), cette expression permet de \"découper\" correctement les tirets pour qu'ils soient correctement alignés sur le cercle (ça ne fonctionnera pas avec d'autres types de formes !)\n\nAjouter en plus dans ce même contour une propriété `Espace` avec le bouton \"+\", puis lier sa valeur à celle du curseur appelé `gap` ;\n\ninitial expression by **Animoplex**\n\nhttps://www.youtube.com/watch?v=I-Acdl_l9G0&list=PLvr5U5ZSt6IzHyvSL9fo0M9NRPsTvra31&index=22","property_types":["1d"],"tags":["shape","layer","dash","circle","gap","slices","dot","stroke","tiret","ring","radial"],"last_update":1572884838386},{"_id":"Auto-walk-cycle--arm-Rot.-1590414907183","code":"var S = _ slider: speed: create _ ; // 3 by default\r\nvar T = _ angle: phase: create _ + _ checkbox: front/back limb: create _*1.56;; // phase is 0 by default\r\nvar A = _ slider: amp: create _*_ slider: Animation multiplier: create _; // 30 by default sur l'amp et 1 sur le multiplier\r\n \r\nvalue-Math.cos((time*S+T)*2)*A","name":"Auto walk-cycle (arm Rot.)","documentation":"Permet d'animer les bras d'un personnage qui marche grâce à l'expression sur les contrôleurs de pieds, en synchronisant le balancement sur leur rotation en fonction de la cadence des pieds (il faut donc dans l'idéal lier la valeur de \"speed\" à celle du MASTER layer qui contrôle aussi le `speed` pour les jambes.\nLes contrôleurs correspondant au haut des jambes (cuisses/start extremities...) devront être parentés à ce calque de bassin/pelvis.\n\nPour décaler le cycle de marche correctement pour la deuxième jambe, il suffit alors de cocher la case \"front/back limb\" (ou de la décocher si elle était cochée pour l'autre).\n\nPour stopper la marche progressivement, ne pas jouer sur le `speed`, mais ajouter des clés sur le curseur `amp` pour le mettre à 0.\n\nA noter que cette expression est à utiliser en complément de celle appelée `auto walk-cycle (foot Pos.)` , ainsi que de l'expression `auto walk-cycle (pelvis Pos.)`.","property_types":["1d"],"tags":["walk","cycle","rig","character"],"last_update":1590417152346},{"_id":"Auto-walk-cycle--foot-Pos.-1590416749099","code":"var S = _ slider: speed: create _ ; // 3 by default\r\nvar A = _ slider: Animation multiplier: create _; // 1 by default\r\nvar L = _ slider: length: create _*A; // 200 by default\r\nvar H = _ slider: height: create _*A; // 200 by default\r\nvar T = _ angle: phase: create _ + _ checkbox: front/back limb: create _*1.56; // phase is 0 by default\r\nvar G = _ layer: floor level: create _; //pick the layer that represents the floor level\r\n\r\nFx=Math.pow(Math.cos((time*S+T)),2) ;\r\nFy = Math.pow(Math.cos((time*S+T)),3)*Math.sin((time*S+T)) ;\r\n[thisComp.width/2, G.transform.position[1]]-[Fx*L,clamp(Fy,0,thisComp.width/2)*H]+[L/2,0]","name":"Auto walk-cycle (foot Pos.)","documentation":"Permet d'animer le contrôleur d'un pied sur la jambe d'un personnage qui est en cinématique inverse (par exemple un contrôleur créé avec DUIK ou RUBBERHOSE).\nIdéalement, les sliders `speed`, `length` et `height` devraient eux-même être liés via expression à un calque MASTER qui permettrait de piloter ces différents aspects de la marche (respectivement la vitesse des pas, leur étendue parcourue en largeur, et leur hauteur), pour les 2 jambes en même temps.\n\nPour décaler le cycle de marche correctement pour la deuxième jambe, il suffit alors de cocher la case \"front/back limb\" (ou de la décocher si elle était cochée pour l'autre).\n\nour stopper la marche progressivement, ne pas jouer sur le `speed`, mais ajouter des clés sur les curseurs `length` et `height` en même temps pour les mettre à 0.\n\nA noter que cette expression est à utiliser en complément de celle appelée `auto walk-cycle (pelvis Pos.)` , ainsi que de l'expression `auto walk-cycle (arm Rot.)`.","property_types":["2d","2d_spatial"],"tags":["walk","cycle","rig","character"],"last_update":1590417123443},{"_id":"Auto-walk-cycle--pelvis-Pos.-1590416469741","code":"var S = _ slider: speed: create _ ; // 3 by default\r\nvar P = _ slider: amp: create _*_ slider: Animation multiplier: create _; // 10 by default\r\nvar T = 1.56 /2 + _ angle: phase: create _ ; // phase is 0 by default\r\n \r\n[value[0],value[1]-Math.sin((time*S+T)*4)*P]","name":"Auto walk-cycle (pelvis Pos.)","documentation":"Permet d'animer le mouvement du bassin/pelvis d'un personnage qui marche grâce à l'expression sur les contrôleurs de pieds, en synchronisant son mouvement de haut en bas sur la cadence des pieds (il faut donc dans l'idéal lier la valeur de `speed` à celle du MASTER layer qui contrôle aussi le `speed` pour les jambes.\nLes contrôleurs correspondant au haut des jambes (cuisses/start extremities...) devront être parentés à ce calque de bassin/pelvis.\n\nPour stopper la marche progressivement, ne pas jouer sur le `speed`, mais ajouter des clés sur le curseur `amp` pour le mettre à 0.\n\nA noter que cette expression est à utiliser en complément de celle appelée `auto walk-cycle (foot Pos.)` , ainsi que de l'expression `auto walk-cycle (arm Rot.)`.","property_types":["2d","2d_spatial"],"tags":["walk","cycle","rig","character"],"last_update":1590417141114},{"_id":"Avoiding-effect--Pos.-1590418916269","code":"var myLayer=_ layer: layerToAvoid: create _;\r\nvar p = myLayer.transform.position;\r\nvar delta = transform.position - p;\r\nvar amplitude = _ slider: amplitude: create _;\r\nvar reach = _ slider: reach: create _;\r\nvar exponent = _ slider: exponent: create _;\r\n\r\nlength = (length(delta));\r\nif(length>0){\r\n        transform.position += normalize( delta ) *  ( reach / Math.pow(length, exponent)  ) * amplitude;\r\n}else{\r\n        transform.position = value ;\r\n}","name":"Avoiding effect (Pos.)","documentation":"Permet de donner un effet \"repoussé\" vraiment intéressant quand on passe un curseur ou n'importe quel calque au dessus d'une multitude d'autres calques (sur la position desquels on vient mettre cette expression et les controlleurs).\n\nLe mieux est encore ensuite de lier les sliders à d'autres sliders du même nom, directement sur le calque qui \"repousse\" (ou le calque \"à éviter !\")\n\nInitial expression by **Matthieu BERNADAT (aka Bernie)**\n\nhttps://berniebernie.fr/wiki/Expressions_and_Tips","property_types":["2d_spatial"],"tags":["repelling","magnet","avoid","position"],"last_update":1590421428643},{"_id":"Bouncing-scale-with-markers-1590419873105","code":"n = 0; \r\n  t = 0; \r\n  if (marker.numKeys > 0){ \r\n      n = marker.nearestKey(time).index; \r\n      if (marker.key(n).time > time) n--; \r\n  } \r\n  if (n > 0) {\r\nt = time - marker.key(n).time;} \r\n     \r\n  var amp = _ slider: amp: create _ ; //15 par exemple \r\n  var freq = _ slider: freq: create _; //5 par exemple\r\n  var decay = _ slider: decay: create _ ; //3 par exemple \r\n     \r\n  var angle = freq * 2 * Math.PI * t; \r\n  var scaleFact = (100 + amp * Math.sin(angle) / Math.exp(decay * t)) / 100; \r\n  [value[0] * scaleFact, value[1] / scaleFact];\r\n","name":"Bouncing scale with markers","documentation":"Créé un effet cartoon \"d'oscillation élastique\" sur l'échelle du calque, à chaque fois que la tête de lecture rencontre un marqueur (réalisé avec la touche * quand le calque est sélectionné).\n\nTrès sympa pour donner de la vie à des éléments d'interface - bouton, menu... - cliqués avec un faux curseur !","property_types":["2d"],"tags":["spring","elastic","bounce","marker"],"last_update":1590420015723},{"_id":"Center-between-2-layers-1582728663327","code":"A = _ layer: Start layer: create _;\r\na = A.transform.position\r\nB = _ layer: End layer: create _;\r\nb = B.transform.position\r\nc = _ slider: Ratio: create _/100;\r\nV=sub(a,b);\r\nb+V*c","name":"Center between 2 layers","documentation":"Permet de placer automatiquement un calque exactement à la moitié de la distance qui sépare 2 autres calques nommés respectivement  `Start Layer` et `End Layer`, en faisant la moyenne de leur 2 positions.\n\nEn faisant varier le curseur `Ratio` (à mettre à 50% pour avoir la moitiée et donc centrer) de 0 à 100, il est possible de faire \"voyager\" le calque du calque Start Layer vers le calque End Layer.\n\nInitial expression by **Matthieu Robert (aka Freelance Saucisse)**\n\n<http://lefreelancesaucisse.blogspot.com/2008/01/expressions-les-vecteurs.html>","tags":["center","middle","mean","moyenne","between","vector"],"last_update":1582729700001},{"_id":"Clamp-wiggle-Pos.-to-bounding-Box-1590420629855","code":"var L = _ layer: my boundingBox layer: create _ ;\r\nvar border = [L.sourceRectAtTime(time).width/2,L.sourceRectAtTime(time).height/2];\r\nvar src = wiggle(2,(Math.max(border[0],border[1])));\r\nclamp(src,value-border,value+border);","name":"Clamp wiggle Pos. to bounding Box","documentation":"En sélectionnant un calque carré ou rectangulaire (solide, bitmap...) A dans la liste déroulante `my boundingBow layer`, et en appliquant cette expression à la position d'un autre calque B, ce calque B va bouger aléatoirement de manière organique (comme un wiggle classique) mais ne dépassera jamais la taille du calque A.\n\nEn dupliquant ensuite ce calque B de multiples fois, on obtient  un effet très sympa de \"mouches contenues dans le calque A (auquel on peut en plus parenter tous les calques qui virevoltent, pour renforcer le côté \"contenu\" si le calque A bouge !)\n\nInitial expression by **Animoplex**\n \nhttps://www.youtube.com/watch?v=MITA3ygqvQY&list=PLvr5U5ZSt6IzHyvSL9fo0M9NRPsTvra31&index=14","property_types":["2d_spatial"],"tags":["bounding","box","flies","wiggle","container"],"last_update":1590421401299},{"_id":"Controled-Wiggle-2D-1590420829358","code":"var A= _ slider: amp: create _;\r\nvar F=_ slider: freq: create _;\r\nvar X=_ slider: X: create _;\r\nvar Y=_ slider: Y: create _;\r\nvar W=wiggle(F,A);\r\n\r\nif(X==1 && Y==1){\r\n[W[0],W[1]];\r\n}else if (X==0 && Y==1){\r\n[value[0],W[1]];\r\n}else if (X==1 && Y==0){\r\n[W[0],value[1]];\r\n}else{\r\nvalue\r\n}","name":"Controled Wiggle 2D","documentation":"Permet de faire varier l'amplitude et la fréquence du `wiggle()` à l'aide de clés, et permet aussi de n'affecter que la dimension de notre choix (un tremblement que sur X ou Y).","property_types":["2d","2d_spatial"],"tags":["wiggle","2d"],"last_update":1590420989973},{"_id":"Coverflow-effect--pos-Z-1590420998654","code":"var sMax = _ slider: maxZ: create _;\r\nvar radius = _slider: easeRadius: create _;\r\nvar target=_ layer: triggerLayer: create _;\r\nvar a = target.transform.position[0];\r\nvar b = thisLayer.toComp(transform.anchorPoint)[0];\r\n\r\nvar l = length(a, b);\r\nvar s = ease(l, 0, radius, sMax, 100);\r\n[0,0,s]+value","name":"Coverflow effect (pos Z)","documentation":"Permet de réaliser des effets de \"coverflow\" très efficaces en fonction de la distance qui sépare le calque auquel est appliquée l'expression (sur la position) et un second calque référencé par la liste déroulante `triggerLayer`.","property_types":["3d"],"tags":["rollover","coverflow","UI","cursor","scale","hover"],"last_update":1590421210699},{"_id":"DUIK-BASSEL-slider-clamp-fix-1590421886326","code":"[clamp(value[0],-effect(1)(8)/2,effect(1)(8)/2),0];","name":"DUIK BASSEL slider clamp fix","documentation":"A utiliser sur la position d'un calque type `C | Slider` créé avec DUIK Bassel lorsqu'on utilise le `Connector`, pour que le curseur (`handle`) reste clampé au bornes min et max de la barre du curseur (le `slider`), l'empéchant ainsi de bouger en dehors des extrémités, beaucoup plus proche ainsi du comportement d'un vrai curseur !","tags":["clamp","duik","slider","fix","UI"],"last_update":1590422163939},{"_id":"DUIK-BASSEL-vector-clamp-fix-1590421967909","code":"[clamp(transform.position[0],-effect(1)(8)/2,effect(1)(8)/2),clamp(transform.position[1],-effect(1)(8)/2,effect(1)(8)/2)];","name":"DUIK BASSEL vector clamp fix","documentation":"A utiliser sur la position d'un calque type `C | Slider` créé avec DUIK Bassel lorsqu'on utilise le `Connector`, pour que le curseur (`handle`) reste clampé au 4 coins du champ vectoriel 2D, l'empéchant ainsi de bouger en dehors des extrémités, beaucoup plus proche ainsi du comportement d'un controlleur de ce type (comme Joystick'N'Slider) !","property_types":["2d_spatial"],"tags":["clamp","duik","fix","UI","vector","2d"],"last_update":1590422180091},{"_id":"Delay-by-layer-index-1590421229469","code":"var delay = framesToTime(_slider: delay (F): create _);\r\nvar myEffect=thisProperty.propertyGroup(1).name;\r\ntry {\r\nvar above = thisComp.layer(index+1).transform(thisProperty.name);\r\n} catch (err){\r\nvar above = thisComp.layer(index+1).effect(myEffect)(thisProperty.name);\r\n}\r\nvar above.valueAtTime(time-delay)","name":"Delay by layer index","documentation":"Permet de séquencer facilement l'animation de multiples calques (en dupliquant le même calque avec l'expression sur la propriété dont on veut faire un décalage temporel).\n\nIl suffit d'appliquer l'expression sur la propriété de transformation (par exemple une position, une échelle, une rotation...) ou une propriété d'effet (comme l'intensité d'une lueur ou le curseur d'un paramètre glissière) sur un seul calque, puis de dupliquer celui-ci autant de fois que nécessaire.\n\nLe décalage temporel se gère avec le curseur `delay (F)` (en nombre d'images, 5 par défaut), sachant qu'il n'est pas nécessaire de bouger les `inPoints` des calques ensuite puisque l'expression s'appuie sur `valueAtTime()`, par rapport au calque qui est juste en dessous de lui (les doublures créées via la commande \"dupliquer\" se faisant toujours par dessus le calque sélectionné). En changeant le \"1\" dans \"(index+1)\" par autre chose (\"2\" par exemple), on peut faire en sorte de se baser sur les calques en dessous 2 par 2 (s'il y a des caches par approche par exemple).\n\nInitial expression by **Animoplex**\n\nhttps://www.youtube.com/watch?v=aIxnJBOhdBw&list=PLvr5U5ZSt6IzHyvSL9fo0M9NRPsTvra31&index=13","tags":["delay","sequence","layers"],"last_update":1590421412996},{"_id":"Delayed-DUIK-Bassel-structures--pos-1590421456502","code":"var delay = _slider: Child Delay: create _ ; // 0.08 soit 1 frame par défaut\r\nparent.fromWorld(toWorld(anchorPoint,time-delay))","name":"Delayed DUIK Bassel structures (pos)","documentation":"Permet de créer un 'secondary motion' de type 'follow through' (effet de trainée et de retard élément par élément dans une hiérarchie) pour donner plus de vie et de souplesse à une structure de bones dans DUIK Bassel (comme une queue d'animal par exemple).\n\nL'expression doit être appliquée uniquement sur la position de chaque articulation qui est un 'enfant' d'une autre articulation (donc le plus haut parent dans la chaîne de calques, qui n'a pas de parent lui même, ne DOIT PAS recevoir cette expression sur sa position sinon il y aura une erreur).\n\nLe slider `Child Delay` sert à ajuster le retard de chaque élément (sachant que 0.04 correspond à la valeur d'une frame/image à 25 img/sec)","property_types":["2d_spatial"],"tags":["delay","offset","follow","through","secondary","duik"],"last_update":1590421875508},{"_id":"Delayed-DUIK-Bassel-structures--rot-1590421690804","code":"var delay = _slider: Child Delay: create _ ; // 0.08 soir 1 frame par défaut\r\nvar pinfluence = _slider: parent Influence: create _; // 100% par défaut\r\n\r\nvalue+(parent.transform.rotation.valueAtTime(time-delay))*pinfluence/100","name":"Delayed DUIK Bassel structures (rot)","documentation":"Dans une chaîne hiérarchique de type structure d'articulations de DUIK ou autres chaine de calques liés pour rigger un personnage ou objet, il peut être utile d'appliquer cette expression à la rotation de chaque enfant de la chaîne (sauf sur le parent le plus haut dans la hiérarchie qui lui n'a pas de parent, sinon ça renverrait une erreur !), afin de donner plus de vie et de réalisme à l'animation ('secondary motion' et 'follow through').\n\nDu coup, le slider `Child Delay` permet de régler le retard de chaque enfant par rapport à son parent, et le slider `parent Influence` donne la possibilité d'influencer plus ou moins la valeur de rotation par celle du parent (0 signifie qu'il ne double pas la rotation du parent, 100 veut dire que l'enfant aura lui-même la même valeur de rotation).","property_types":["1d"],"tags":["delay","offset","follow","through","secondary","duik"],"last_update":1590421858708},{"_id":"Duplicate-in-radial-way-1590422332503","code":"var N = thisComp.numLayers ;\n\nindex*(360/N);","name":"Duplicate in radial way","documentation":"Permet d'adapter la `rotation` de calques qu'on duplique pour que les calques une fois dupliqués soient disposés en un cercle parfait.\n\nATTENTION, ça ne peut fonctionner que s'il n'y a QUE ces calques dans la composition. Dès lors qu'on ajoute autre chose, les index sont changés et ça ne fonctionnera plus ! L'idéal est alors de précomposer l'ensemble pour le ré-utiliser ailleurs (ou alors s'assurer que seuls les calques dupliqués avec cette expression restent bien les premiers de la comp, tout en haut).","property_types":["1d"],"tags":["duplicate","clone","radial","circle","index"],"last_update":1590422457963},{"_id":"Fixed-Mask-while-animating-transform-1590422475543","code":"var fixedTime = 0; //choisir le temps ou verrouillé le mask\r\n\r\nvar origPath = thisProperty;\r\n\r\nvar origPoints = origPath.points(); \r\nvar origInTang = origPath.inTangents(); \r\nvar origOutTang = origPath.outTangents(); \r\n\r\nfor(var i = 0 ; i < origPoints.length ; i++){\r\n    inTangTemp = fromWorld( toWorld( origPoints[i] + origInTang[i], fixedTime)) ;  \r\n    outTangTemp = fromWorld( toWorld( origPoints[i] + origOutTang[i], fixedTime)) ;  \r\n    origPoints[i] = fromWorld( toWorld( origPoints[i], fixedTime)) ;\r\n    origInTang[i] =  inTangTemp - origPoints[i];\r\n    origOutTang[i] = outTangTemp - origPoints[i]  ;\r\n\r\n}\r\n\r\ncreatePath(origPoints,origInTang,origOutTang,origPath.isClosed());","name":"Fixed Mask while animating transform","documentation":"Permet de laisser figés les points et tangentes d'un `tracé de masque` dans l'espace 2D de la comp, tandis que les principales propriétés de Transformation (position,échelle, rotation) du calque sont animées.\n\nPour que l'expression fonctionne, vous devez créer obligatoirement des images clés sur la position, l'échelle et/ou la rotation du calque (sans l'animation, le masque héritera des transformations du calque comme il le fait d'habitude).\n\nTrès utile pour créer des évidements et autres parties cachées tandis qu'une forme ou un texte est animée (permet de ne garder qu'un seul calque unique plutôt que de jouer sur des doublons calques caché/cache) !\n\nInitial expression by **Matthieu Wlazinsky (aka Lakpo)**","property_types":["other"],"tags":["mask","path","fixed","static"],"last_update":1590422584507},{"_id":"Fixed-Scale-on-parent-resize-1590422611318","code":"var s = [];\r\nvar ps = parent.transform.scale.value;\r\nfor (i = 0; i < ps.length; i++){\r\ns[i] = value[i]*100/ps[i];\r\n}\r\ns","name":"Fixed Scale on parent resize","documentation":"Permet de garder la même échelle tandis qu'on redimensionne le `parent` du calque (parfait pour créer toutes sortes d'arrangements types Cloneurs animés !).\nAttention de ne bien appliquer cette expression qu'à des calques qui possèdent bien un parent !\n\nInitial expression by **Jr Canest**\n\nhttps://docs.google.com/spreadsheets/d/1a3ArTUHAJwVi-ObZofvz6IfrKbSGSENlaTIRTs8pAJU/edit#gid=0","tags":["fixed","scale","transparent","resize","static"],"last_update":1590422839051},{"_id":"Fixed-Stroke-Width-on-posZ-1590422703901","code":"var nominalDist = _ slider: nominalDist: create _ ; //200 par défaut\r\ntry{\r\nvar d = length (thisComp.activeCamera.toWorld([0,0,0]),toWorld(anchorPoint));\r\nvalue*(d/nominalDist);\r\n}catch(e){\r\nvalue;\r\n};","name":"Fixed Stroke Width on posZ","documentation":"Permet de garder la même épaisseur de contour même lorsqu'on déplace un calque de forme sur son axe Z\n\nInitial expression by **Jr Canest**\n\nhttps://docs.google.com/spreadsheets/d/1a3ArTUHAJwVi-ObZofvz6IfrKbSGSENlaTIRTs8pAJU/edit#gid=0","tags":["fixed","width","stroke","thickness","Z","depth","static"],"last_update":1590422816732},{"_id":"Fixed-Stroke-Width-on-resize-1590422858460","code":"try{\r\nvar s = scale [0]/100;\r\nvar L = thisLayer;\r\nwhile (L.hasParent){\r\nvar s *= L.parent.scale[0]/100;\r\nvar L = L.parent;\r\n}\r\nvar w = value;\r\nw/s\r\n}catch(e){\r\nvalue;\r\n};","name":"Fixed Stroke Width on resize","documentation":"Permet de garder la même épaisseur de contour même lorsqu'on agrandit un calque de forme (peut-être très utile pour du Rubberhose par exemple)\n\nInitial expression by **Jr Canest**\n\nhttps://docs.google.com/spreadsheets/d/1a3ArTUHAJwVi-ObZofvz6IfrKbSGSENlaTIRTs8pAJU/edit#gid=0","tags":["fixed","width","stroke","thickness","static","resize"],"last_update":1590422908795},{"_id":"Flickering-Light-ON-1590422922878","code":"var I= _slider: Flickering Anim: create _/100;\r\nMath.round(.25+ I/2+ wiggle(20,.25))","name":"Flickering Light ON","documentation":"Permet de faire trembler l'intensité d'une lumière type néon (ou une opacité) pendant l'allumage progressif - animé par le slider qui va de 0 à 100 - puis de ne plus le faire trembler une fois allumé\n\nInitial expression by **Matthieu ROBERT (aka Freelance Saucisse)**\n\nhttp://lefreelancesaucisse.blogspot.com/2010/02/faux-contact.html","property_types":["1d"],"tags":["flicker","random","opacity","light","matthieu","robert","saucisse"],"last_update":1590423448547},{"_id":"Flickering-Light-PERPETUAL-1590423036102","code":"var segMin = _slider: segMin: create _; //minimum segment duration\r\nvar segMax = _slider: segMax: create _; //maximum segment duration\r\nvar flickerDurMin = _slider: flickerDurMin: create _;;\r\nvar flickerDurMax = _slider: flickerDurMax: create _;;\r\n\r\nvar end = 0;\r\nvar j = 0;\r\nwhile ( time >= end){\r\n  j += 1;\r\n  seedRandom(j,true);\r\n  start = end;\r\n  end += random(segMin,segMax);\r\n}\r\nflickerDur = random(flickerDurMin,flickerDurMax);\r\nif (time > end - flickerDur){\r\n  seedRandom(1,false);\r\n  random(_slider:Min Value: create _,_slider:Max Value: create _);\r\n}else{\r\n  _slider:Fixed Value: create _;\r\n}","name":"Flickering Light PERPETUAL","documentation":"Permet de faire trembler l'intensité d'une lumière type néon (ou une opacité) de manière perpétuelle (permet de donner un côté \"glytchy\" à des éléments lumineux par exemple.\n\nInitial expression by **Dan EBBERTS**\n\nhttp://www.motionscript.com/mastering-expressions/random-3.html\n","property_types":["1d"],"tags":["flicker","random","perpetual","glitch","light","opacity","DAN EBBERTS"],"last_update":1590423430748},{"_id":"Holdtime-random-1-dimension-1590423258958","code":"var holdTime = _ slider: holdTime: create _ ; //time to hold each position (seconds)\r\nvar minVal = _slider: minVal: create _;\r\nvar maxVal = _slider: maxVal: create _;\r\n\r\nvar seed = Math.floor(time/holdTime);\r\nseedRandom(seed,true);\r\nrandom(minVal,maxVal)","name":"Holdtime random 1 dimension","documentation":"Permet de randomiser une valeur à `1 seule dimension` (intensité, opacité...) dans le temps mais en la \"figeant\" à un certain framerate/une certaine cadence (comme s'il sagissait d'un `wiggle()` sur lequel on aurait ajouté un effet `postérisation temporelle`).\n\nL'amplitude se gère en changeant les valeurs des curseurs `minVal` et `maxVal`, tandis que le curseur `holdTime` sert de fréquence pour le maintien en place (la valeur est en secondes)\n\nInitial expression by **Dan EBBERTS**\n\nhttp://www.motionscript.com/mastering-expressions/random-1.html","tags":["random","hold","posterize","time remap","DAN EBBERTS"],"last_update":1590423417163},{"_id":"Holdtime-random-2-dimensions--Pos-1590423471684","code":"var holdTime = _ slider: holdTime: create _ ; //time to hold each position (seconds)\r\nvar minVal = _point: minVal: create _;\r\nvar maxVal = _point: maxVal: create _;\r\n\r\nvar seed = Math.floor(time/holdTime);\r\nseedRandom(seed,true);\r\nvalue+random(minVal,maxVal)","name":"Holdtime random 2 dimensions (Pos)","documentation":"Permet de randomiser une valeur à `2 dimensions` (position 2D, échelle...) dans le temps mais en la \"figeant\" à un certain framerate/une certaine cadence (comme s'il sagissait d'un `wiggle()` sur lequel on aurait ajouté un effet `postérisation temporelle`).\n\nL'amplitude se gère en changeant les valeurs `minVal` et `maxVal` des points d'effets, tandis que le curseur `holdTime` sert de fréquence pour le maintien en place (la valeur est en secondes)\n\nInitial expression by **Dan EBBERTS**\n\nhttp://www.motionscript.com/mastering-expressions/random-1.html","property_types":["2d","2d_spatial"],"tags":["random","hold","posterize","time remap","DAN EBBERTS","2d"],"last_update":1590423586980},{"_id":"Inertial-bounce-1590423616373","code":"var amp = _slider: amp: create _; // .1 or 0.25 for exemple\r\nvar freq = _slider: freq: create_; // 2 or 1 for example\r\nvar decay = _slider: decay: create_; // 2 or 5 for exemple\r\n\r\nvar n = 0;\r\n\r\nvar time_max = 2;\r\n\r\nif (numKeys > 0){\r\nn = nearestKey(time).index;\r\nif (key(n).time > time){\r\nn--;\r\n}}\r\nif (n == 0){ t = 0;\r\n}else{\r\nt = time - key(n).time;\r\n}\r\nif (n > 0 && t < time_max){\r\nv = velocityAtTime(key(n).time - thisComp.frameDuration/10);\r\nvalue + v*amp*Math.sin(freq*t*2*Math.PI)/Math.exp(decay*t);\r\n}else{value}","name":"Inertial bounce","documentation":"Permet de donner un aspect \"rebond elastique\" sur la propriété animée, comme avec le `Spring` de DUIK\n\nInitial expression by **Harry Frank (Graymachine)**\n\nhttps://www.graymachine.com/top-5-effects-expressions/\n","tags":["elastic","overlap","secondary","motion","bounce","spring"],"last_update":1598614517404},{"_id":"Isometric-constrained-movement-1590423765309","code":"var pos = transform.position;\r\nvar x = _slider: X Movement: create _;\r\nvar y = _slider: Y Movement: create _;\r\nvar z = _slider: Z Movement: create _;\r\n[x*Math.sqrt(3) + z*Math.sqrt(3) + pos[0], -x + z + y + pos[1]];","name":"Isometric constrained movement","documentation":"Permet de contraindre la position de calques `2D` sur les 3 axes typiques d'une `isométrie`. À utiliser surtout sur des graphismes et illustrations isométriques en 2D, pour les animer dans une fausse perspective isométrique.\n\nInitial expression by **Alejandro Sanclemente**\n\nhttps://www.youtube.com/watch?v=XGhu4msX35Q","property_types":["2d_spatial"],"tags":["isometric","constrain"],"last_update":1590423909763},{"_id":"Living-eyes--a-la-PIXAR-1590423929558","code":"var holdTime = _slider: holdTime: create _; // en secondes, 0.5 par exemple\r\nvar amp = _slider: Amp: create_ ;\r\nvar minVal = [-amp,-amp]; \r\nvar maxVal = [amp,amp];\r\nvar seed = Math.floor(time/holdTime);\r\nseedRandom(seed,true);\r\nrandom(minVal,maxVal)+value","name":"Living eyes \"à la PIXAR\" ( 2 dimensions)","documentation":"Permet de faire bouger légèrement (expression à mettre sur la `position 2D` donc) la pupille d'un oeil de personnage de manière saccadée, pour lui donner un regard moins figé, plus vivant, comme les personnages de dessins animés type PIXAR.\n\nLes paramètres `holdTime` et `Amp` permettent respectivement de jouer sur la fréquence du mouvement (en secondes) et sur l'amplitude.","tags":["pixar","living","hold","posterize","time remap","position","eyes"],"last_update":1590424486187},{"_id":"Living-prop--a-la-PIXAR----1-dimension-1590424234948","code":"var holdTime = _slider: holdTime: create _; // en secondes, 0.5 par exemple\r\nvar amp = _slider: Amp: create_ ; // 10px par exemple\r\nvar minVal = -amp; \r\nvar maxVal = amp;\r\nvar seed = Math.floor(time/holdTime);\r\nseedRandom(seed,true);\r\nrandom(minVal,maxVal)+value","name":"Living prop \"à la PIXAR\" ( 1 dimension)","documentation":"Permet de faire trembler légèrement et de manière saccadée une propriété à `une dimension` (par exemple la rotation, ou l'opacité), pour lui donner plus de vie.\n\nLes paramètres `holdTime` et `Amp` permettent respectivement de jouer sur la fréquence du mouvement (en secondes) et sur l'amplitude.","property_types":["1d"],"tags":["pixar","living","hold","posterize","time remap"],"last_update":1590424344140},{"_id":"LookAt--2D-1582729851690","code":"a=position;\r\nB = _ layer: Look At This Layer: create _;\r\nb = B.transform.position\r\nr = _ angle: Rotation offset: create _;\r\nV = sub(b,a);\r\nradiansToDegrees ( Math.atan2 ( V[1],V[0] )) + r","name":"LookAt (2D)","documentation":"Permet de cibler automatiquement un calque 2D sur un autre calque 2D (choisi dans la liste `Look At This Layer`), en le tournant sur son axe de rotation pour \"pointer\" vers ce calque.\n\nInitial expression by **Matthieu Robert (aka Freelance Saucisse)**\n\n<http://lefreelancesaucisse.blogspot.com/2009/03/look-me-in-2d.html>","tags":["vector","lookAt","rotation","2d"],"last_update":1582730115250},{"_id":"Loop-Mask-1590424556966","code":"if (numKeys >1 && time > key(numKeys).time){\r\n  t1 = key(1).time;\r\n  t2 = key(numKeys).time;\r\n  span = t2 - t1;\r\n  delta = time - t2;\r\n  t = delta%span;\r\n  valueAtTime(t1 + t)\r\n}else{\r\n  value;\r\n}","name":"Loop Mask","documentation":"Permet comme son nom l'indique de boucler une animation de `tracé de masque` à base d'images clés (puisque le LoopOut() ne fonctionne pas sur les masques) \n\nInitial expression by **Jr Canest**\n\nhttps://docs.google.com/spreadsheets/d/1a3ArTUHAJwVi-ObZofvz6IfrKbSGSENlaTIRTs8pAJU/edit#gid=0","tags":["loop","mask","path"],"last_update":1590424619915},{"_id":"Orbit-trajectory--Pos.-1590424630878","code":"var radius = _slider: radius: create_ ;\nvar speed = _slider: speed: create_;\nvar phase = _angle: phase: create_;\nvalue + [Math.sin((time+phase)*speed)*radius, -Math.cos((time+phase)*speed)*radius]","name":"Orbit trajectory (Pos.)","documentation":"Permet de donner une trajectoire circulaire animée à la `position 2D` d'un calque.\n\nLe rayon du cercle, la vitesse et le décalage de phase se gèrent respectivement grâces au controls `radius`, `speed` et `phase` (ce dernier paramètre est utile pour décaler plusieurs occurences de calques - après avoir été dupliqués par exemple - et les arranger sur la forme de cercle).\n\nÀ noter qu'il est possible d'animer la position avec des clés, sur la position Z notamment, pour créer des effets de spirale très utiles !\n\nInitial expression by **Adobe**\n\nhttps://helpx.adobe.com/fr/after-effects/using/expression-examples.html","tags":["circle","radial","trigonometry","orbit","position"],"last_update":1590425027827},{"_id":"Radial-delay-1590425042406","code":"//Apply to Time Remap\r\nvar pos = transform.position;\r\nvar delay = -_slider: timeOffset: create _*thisComp.frameDuration; //in frames\r\nvar x = Math.pow(pos[0]-thisComp.width/2,2);\r\nvar y = Math.pow(pos[1]-thisComp.height/2,2);\r\nvar d = Math.sqrt(x+y);\r\nvalue + linear(d,0,1102,0,delay);","name":"Radial delay","documentation":"Permet de décaler une multitude de mêmes animations (animation précomposée au préalable, avec cette expression sur une propriété `timeRemap`, puis dupliquée) dans le temps depuis le centre de la composition vers les coins extérieurs de la composition, donnant un effet de \"delai radial\" semblable à ce qu'on pourrait obtenir avec un `effecteur` en mode \"Sphere\" dans C4D.\n\nLe délai est basé sur le curseur `timeOffset` (en nombre d'images) ; idéalement ce curseur devrait être lui-même lié à un Master contrôlleur qui a le même paramètre pour gérer plus efficacement le timeOffset de tous les calques à la fois.\n\nInitial expression by **Joe CLAY (Workbench)**\n\nhttps://workbench.tv/tutorials/2016-02-04_RadialDelay","tags":["time remap","delay","circle","radial","center"],"last_update":1590425216068},{"_id":"Random-Color-from-colors-1590425232310","code":"var C1 = _color: Color 1: create _;\r\nvar C2 = _color: Color 2: create _;\r\nvar C3 = _color: Color 3: create _;\r\nvar C4 = _color: Color 4: create _;\r\n\r\nvar colors=[C1,C2,C3,C4];\r\n\r\nvar V = _slider: Change color: create _; // faire varier de 1 à 4 pour cycler dans les couleurs\r\n\r\nseedRandom(V, true);\r\n\r\nvar amCol = colors.length ; //Number of colours in the list above\r\ncolors[Math.floor(random(amCol-0.0001))];","name":"Random Color from colors","documentation":"Permet de randomiser une couleur parmi un `choix de 4 couleurs prédéfinies` (ajuster l'expression ET les effets si besoin de plus ou moins), et de changer cette couleur au cours du temps grâce au slider `change color`.\n\nInitial expression by **Jr Canest**\n\nhttps://docs.google.com/spreadsheets/d/1a3ArTUHAJwVi-ObZofvz6IfrKbSGSENlaTIRTs8pAJU/edit#gid=0","tags":["color","random","array"],"last_update":1590425569067},{"_id":"Random-grid-movement-1590425588630","code":"var origin =  _point: origin: create _; //upper left hand corner of grid\r\nvar dimX =  _slider: dimX: create _; //number of columns\r\nvar dimY =  _slider: dimY:  create _; //number of rows\r\nvar gap =  _slider: gap: create _; // distance between cells (pixels)\r\nvar gridRate =  _slider: gridRate: create_; //speed (pixels per second)\r\nvar holdTime =  _slider: holdTime: create_; //(seconds)\r\n\r\nvar end = 0;\r\nvar j = 0;\r\n\r\nwhile (time >= end){\r\n  seedRandom(j,true);\r\n  var startX = Math.floor(random(dimX))*gap + origin[0];\r\n  var startY = Math.floor(random(dimY))*gap + origin[1];\r\n  j +=1;\r\n  seedRandom(j,true)\r\n  start = end;\r\n  endX = Math.floor(random(dimX))*gap + origin[0];\r\n  endY = Math.floor(random(dimY))*gap + origin[1];\r\n  deltaX = Math.abs(endX - startX);\r\n  deltaY = Math.abs(endY - startY);\r\n\r\n  end += (deltaX + deltaY)/gridRate + 2*holdTime;\r\n}\r\n\r\nvar p1 = start + deltaX/gridRate;\r\nvar p2 = p1 + holdTime;\r\nvar p3 = p2 + deltaY/gridRate;\r\n\r\nif (time < p1){\r\n  ease(time,start,p1,[startX,startY],[endX,startY])\r\n}else if (time < p2){\r\n  [endX,startY]\r\n}else if (time < p3){\r\n  ease(time,p2,p3,[endX,startY],[endX,endY])\r\n}else{\r\n  [endX,endY]\r\n}","name":"Random grid movement","documentation":"Permet d'animer automatiquement une multitude de calques (par exemple des petits solides carrés) le long d'une `grille` définie en nombre de colonnes et de lignes via les sliders `dimX` et `dimY`.\n\nL'origine de la grille peut-être déplacée grâce au contrôle appelé `origin`, et on peut changer également la vitesse via `gridRate` (en pixels par secondes), l'écartement entre les points de la grille via `gap` (en pixels) et la durée pendant laquelle les calques restent fixes avec `holdTime` (en secondes).\n\nInitial expression by **Dan EBBERTS**\n\nhttp://www.motionscript.com/expressions-lab-ae65/random-grid-movement.html\n","property_types":["2d_spatial"],"tags":["grid","random","position","DAN EBBERTS","movement","cells","table"],"last_update":1590425851124},{"_id":"Realistic-handwritting-1590425859974","code":"L= _ layer: myWrittingNull: create _;\r\nu = L.toWorldVec([1,0]);\r\nr = radiansToDegrees(Math.atan2(u[1],u[0]))/180;\r\nlinear(r,0,source.duration)","name":"Realistic handwritting","documentation":"Utilisée avec un métrage réel de main filmée avec un crayon, cette expression sur la propriété `timeRemap` permet d'ajouter beaucoup plus de réalisme pour les animations de type \"scribbing\" habituellement réalisées avec une simple photo de main parentée à un objet NULL.\n\nVoici comment ça fonctionne :\nd'abord créer un `Null` puis copier-coller le `tracé de masque` de l'écriture préalablement dessinée à la plume dans sa propriété de `position` ;\npuis, après avoir auto-orienté (avec la commande clic-droit sur le Null > Geometry > `auto orient`) le Null sur le chemin, ajouter l'expression sur le `TimeRemap` de notre main animée pré-composée, puis bien choisir le Null dans le paramètre calque `myWrittingNull`.\n\nInitial expression by **Jorrit Schulte**\n\nhttps://www.youtube.com/watch?v=ADVKZJGyyZ0\n","tags":["hand writting","scribbing","auto","orientation","path","time remap"],"last_update":1590426072964},{"_id":"Responsive-Text-Scale-1640777400236","code":"maxW = _ slider: maxWidth: create _ ; \r\nmaxH = _ slider: maxHeight: create _ ; \r\nw = sourceRectAtTime(time).width ;\r\nh = sourceRectAtTime(time).height ;\r\ns = w/h > maxW/maxH ? maxW/w : maxH/h ;\r\n[100,100]*s;","name":"Responsive Text Scale","documentation":"Automatically rescale a Text layer (or any kind of layer, even it has initially been designed for titles and lower thirds) so that its width and height will will adapt to a predefined bounding box of `maxWidth` and `maxHeight` pixels (can't be set to 0 or there will be an error!).\n\nInitial expression by **Creative Dojo**\nhttps://www.youtube.com/watch?v=-n0RKDlbGas\n","property_types":["2d"],"tags":["adapt","fluid","layout","title","lower third","scale","resize","text"],"last_update":1640777777685},{"_id":"Rolling-square--Pos-1590480732986","code":"var cote = width*scale[0]/100; \r\nvar diagonale = cote*Math.pow(2,.5); \r\nvar montee = (diagonale-cote)/2;\r\n\r\nvar y = Math.abs ( Math.sin ( degreesToRadians ( (rotation))*2))*-montee;\r\n\r\n[0,y]+value","name":"Rolling square (Pos)","documentation":"Permet de faire \"remonter\" (expression à ajouter sur la `position 2D`  donc) un design carré (un solide de 100x100 par exemple) sur son axe Y à chaque fois qu'il bouge sur X de manière à garder le maintenir \"plaqué\" sur son bord droit comme sur un sol, malgré la `rotation` animée pour le faire \"rouler\" (ne pas oublier d'appliquer l'expression complémentaire `Rolling square (Rot)` sur la `rotation` de ce même calque.\n\nInitial expression by **Matthieu ROBERT (aka Freelance saucisse)**\n\nhttp://lefreelancesaucisse.blogspot.com/2009/04/marchons-carre.html","tags":["auto","roll","square","carré","position","freelance","saucisse"],"last_update":1590480882551},{"_id":"Rolling-square--Rot-1590480890522","code":"var cote = _ slider: Size: create _*scale[0]/100;\r\nvar x = transform.position[0];\r\n(x/cote)*90","name":"Rolling square (Rot)","documentation":"Permet de tourner (expression à ajouter sur la `rotation` donc) le calque comme une \"roue\" lorsqu'on le déplace sur sa position X, mais en prenant en compte le fait que le bas reste aligné sur le sol grâce à l'expression sur la `position` (ne pas oublier d'appliquer l'expression complémentaire `Rolling square (Pos)` sur ce même calque, et d'adapter le paramètre glissière appelé `Size` pour que ça corresponde effectivement à la dimension X du calque.\n\nInitial expression by **Matthieu ROBERT (aka Freelance Saucisse)**\n\nhttp://lefreelancesaucisse.blogspot.com/2009/04/marchons-carre.html","tags":["auto","rollover","square","carré","freelance","saucisse","rotation"],"last_update":1590481035429},{"_id":"Rollover-effect-1590481060319","code":"var sMax =_slider: maxScale: create _;\r\nvar radius = _slider: easeRadius: create _;\r\nvar target=_ layer: triggerLayer: create _;\r\nvar a = target.transform.position[1];\r\nvar b = position[1];\r\n\r\nvar l = length(a, b);\r\nvar s = ease(l, 0, radius, sMax, 100);\r\n[s,s]+value-[100,100]","name":"Rollover effect","documentation":"Permet de réaliser des effets de \"rollover\" très efficaces en fonction de la `distance` qui sépare le calque auquel est appliquée l'expression (sur la propriété `échelle`) et un second calque référencé par la liste déroulante `triggerLayer` (qui peut être un design de curseur ou un objet NUL par exemple).\n\nInitial expression by ** Harry Frank (Graymachine) **\n\nhttps://www.graymachine.com/tutorials/automating-highlight-rollover-effects-in-adobe-after-effects/","tags":["rollover","hover","cursor","UI","scale","distance","length"],"last_update":1590481288478},{"_id":"Rotating-Squares-inside-Squares-1591866091952","code":"var L = 100;\r\nvar ang = degreesToRadians(content(\"Rectangle 1\").content(\"Repeater 1\").transform.rotation); //remplacer ici ce qu'il y a entre les parentheses de la fonction degreesToRandians() par le chemin vers la propriété rotation du repeater juste en dessous avec le lasso\r\nvar c = L/(Math.cos(ang) + Math.sin(ang));\r\n[c,c];","name":"Rotating Squares inside Squares","documentation":"Permet d'ajuster automatiquement l'échelle de chaque copie d'un carré en calque de forme via le `repeater`, en fonction de la `Rotation` de ces dernières (toujours via le Repeater, soit la propriété `ADBE Vector Repeater Rotation`).\nCette expression est donc à appliquer à la propriété `ADBE Vector Repeater Scale`.\nNe pas oublier de remplacer ce qu'il y a entre les parenthèses de la fonction degreesToRandians() par le chemin vers la propriété rotation du repeater juste en dessous avec le lasso.\nTout se gère alors dans le \"Repeater\" (le nombre de copies importe peu, il n'est pas pris en compte dans l'expression).\nLa valeur de la variable `L` (par défaut à 100%) correspond au ratio ; si on laisse 100, ça veut dire que les coins de chaque copie des carrés vont toucher parfaitement les bords de la copie précédente ; si on fait varier cette valeur, ça agit comme un multiplieur d'échelle.\n\nInitial expression by **Chetal Gazdar**\n\nhttps://www.youtube.com/watch?time_continue=98&v=gCgHb-TZmhk&feature=emb_logo","tags":["resize","scale","repeater","shape","rotation","twirl","spiral"],"last_update":1591866993761},{"_id":"Rubberize-it--Formula-A-1590481342487","code":"a7=_slider: freq: create_;// entre 0.5 et 9 par défaut\r\na8=_slider: decay: create_; //entre 0.5 et 9 par défaut\r\na9=1/_slider: amp: create_;\r\na0=toComp(anchorPoint);a1=value;a2=value-anchorPoint;a3=toComp(a1)-a0;a4=0;a10=125;if(length(a3)>.01){a5=thisComp.frameDuration;a6=time;a11=[0,0];a12=a7*Math.PI*2;a13=toComp(a1,a6+a5/2);for(a23=a10;a23>0;a23--){a14=toComp(a1,a6);a15=(a13-a14);a16=toComp(a1,a6-a5/2);a17=(a14-a16);a18=a15-a17;a19=time-a6;if(length(a18)>.01){a11=a18*Math.sin(a19*a12)/Math.exp(a19*a8);a3=a14-toComp(anchorPoint,a6);if((length(a3)>.001)&&(length(a11)>.001)){a20=normalize([-a3[1],a3[0]]);a4+=dot(a20,a11);}}a6-=a5;a13=a16;}a4/=a9*a10;}a21=Math.cos(-a4);a22=Math.sin(-a4);anchorPoint+[a2[0]*a21-a2[1]*a22,a2[0]*a22+a2[1]*a21];","name":"Rubberize it (Formula A)","documentation":"Permet de donner un effet \"mou\" / \"soft body\" à n'importe quel calque animé, si l'expression est appliquée sur la `position de coins de marionnette` !\nD'autres applications sympas peuvent être trouvées, à condition d'utiliser l'expression sur une `propriété à 2 dimensions` (par exemple le \"To\" de l'effet \"CC Smear\" pour créer des effets d'antennes animées).\n\nIl suffit alors d'animer le calque en position, et le calque se déforme de manière naturelle (Cette formule A donne l'impression que les points/coins sont contraints en rotation autour du `point d'ancrage` du calque).\n\nInitial expression from **Rubberize it !**, a plugin developped by **Dan Ebberts** and **Orrin Zucker**\n\nhttps://aescripts.com/rubberize-it/","property_types":["2d","2d_spatial"],"tags":["soft","elastic","spring","dynamic","puppet","pins","DAN EBBERTS","hack","rubber","cartoon"],"last_update":1590481660846},{"_id":"Rubberize-it--Formula-B-1590481688702","code":"a7=_slider: freq: create_;// entre 0.5 et 9 par défaut\r\na8=_slider: decay: create_; //entre 0.5 et 9 par défaut\r\na9=1/_slider: amp: create_;\r\na1=value;a11=[0,0];a5=thisComp.frameDuration;a6=time;a10=63;a12=a7*Math.PI*2;for(a23=a10;a23>0;a23--){try{a13=fromComp(toComp(a1,a6+a5/2));a14=fromComp(toComp(a1,a6));a16=fromComp(toComp(a1,a6-a5/2));}catch(e){a6-=a5;continue;}a15=(a13-a14);a17=(a14-a16);a18=a15-a17;a19=time-a6;if(length(a18)>.01){a11+=a18*Math.sin(a19*a12)/Math.exp(a19*a8);}a6-=a5;}value-a11*4/a9;","name":"Rubberize it (Formula B)","documentation":"Permet de donner un effet \"mou\" / \"soft body\" à n'importe quel calque animé, si l'expression est appliquée sur la `position de coins de marionnette` !\nD'autres applications sympas peuvent être trouvées, à condition d'utiliser l'expression sur une `propriété à 2 dimensions` (par exemple le \"To\" de l'effet \"CC Smear\" pour créer des effets d'antennes animées).\n\nIl suffit alors d'animer le calque en position, et le calque se déforme de manière naturelle (Cette formule B utilise plutôt la `position` de chaque point qu'une contrainte de rotation autour du point d'ancrage).\n\nInitial expression from **Rubberize it !**, a plugin developped by **Dan Ebberts** and **Orrin Zucker**\n\nhttps://aescripts.com/rubberize-it/","property_types":["2d","2d_spatial"],"tags":["soft","elastic","spring","dynamic","puppet","pins","DAN EBBERTS","hack","rubber","cartoon"],"last_update":1590482880208},{"_id":"Smooth-keyframes-1572530014823","code":"W = _ slider: range width: create_; // in seconds, the range of keyframes to sample around\r\nS = _ slider: samples: create _; // has to be between 1 and 100\r\nsmooth(W, S)","name":"Smooth keyframes","documentation":"Idéal pour lisser des clés issues d'un `tracking` par exemple !\nLe premier curseur `range width` permet de définir le nombre de secondes à prendre en compte dans le lissage (par exemple à 0.5, les clés de -0.25sec à +0.25sec autour du moment T seront prises en compte dans l'algorythme de lissage.) \nLe paramètre `samples` quant à lui permet de définir la précision du lissage (entre 1 et 100). Au plus la valeur est grande, au plus on tend vers la courbe d'origine, et au plus la valeur est petite, au plus le lissage est fort et le résultat s'éloigne de la courbe initiale.","tags":["smooth","track","keys","keyframes","lissage","clean"],"last_update":1579249036194},{"_id":"Snap-Dezoom--continuous-scale-1590481859776","code":"var trans = _slider: transitionTime: create_; //  transition time in frames\r\nvar dezoom = _slider: progrDezoom: create_;\r\nvar s = _slider: snapScale: create_ ;\r\nvar midTime = (outPoint-inPoint)/2;\r\nif(time > inPoint+midTime){\r\nvar snapScale = -clamp(s,0,100);\r\n}else{\r\nvar snapScale = s;\r\n}\r\ntrans = trans * thisComp.frameDuration;\r\nvar inTrans  = easeOut(time, inPoint, inPoint + trans, [snapScale,snapScale], [0,0]);\r\nvar outTrans = easeIn(time, outPoint, outPoint - trans, [0,0], [snapScale, snapScale]);\r\nclamp((value+ inTrans + outTrans + (time-inPoint)*-[dezoom,dezoom]),[0,0],[100000,100000])","name":"Snap Dezoom (continuous scale)","documentation":"Permet d'animer l' `échelle` automatiquement sur les calques concernés en se basant sur le `inPoint` (entrée) et le `outPoint` (sortie) avec une durée de transition (`transitionTime`) personnalisée, ainsi qu'un léger dézoom continu (`progrDezoom`) pour apporter du dynamisme.\n\nDiffère de l'autre variante `Snap zoom inOut (ping pong scale)` car le calque poursuit son mouvement vers l'arrière.\n\nTrès pratique pour l'apparition de pictogrammes, de logos ou de titrages multiples ! Peut-être combiné avec l' `auto fade` qui se basera alors sur la même vitesse de transition.\n\nInitial expression by **Harry Frank (Graymachine)**, adapted by **Matthieu Fremeaux (aka FREMOX)**\n\nhttps://www.graymachine.com/top-5-effects-expressions/","property_types":["2d"],"tags":["auto","snap","scale","zoom","dezoom","continuous","progressive","text","trailer","inOut"],"last_update":1590482874246},{"_id":"Snap-Translation-Animation-1640777060170","code":"hDist = Math.round(_ slider: increment: create _);\r\nvDist = hDist; // change it if you don't want a uniform X:Y ratio for the grid cell\r\nx = Math.floor(value[0]/hDist)*hDist;\r\ny = Math.floor(value[1]/vDist)*vDist;\r\n[x,y]","name":"Snap Translation Animation","documentation":"Constrains the movement of layer onto a grid (like for a Pacman for example), with a the grid's cell's size defined by the `increment` slider (it has to be bigger than 0, otherwise there will be an error!)\n\nInitial expression by **Dan Ebberts**\nhttps://creativecow.net/forums/thread/need-to-snap-translation-animation-to-points-on-a/ ","property_types":["2d"],"tags":["snap","grid","translation","position","2d","constrain"],"last_update":1640777362880},{"_id":"Snap-to-layer-1590482276691","code":"try{\r\nvar L = _layer: snapToLayer: create_;\r\n}catch(e){\r\nvar L = false;\r\n}\r\nif(L) {\r\nL.toComp(L.anchorPoint);\r\n}else\r\nvalue;\r\n}","name":"Snap to layer","documentation":"Permet de fixer un calque sur un autre automatiquement (expression à appliquer sur la `position` donc), en ayant la possibilité de sélectionner le calque dans la liste déroulante `snapToLayer`.\n\nSi le calque lui-même est choisi ou si aucun calque n'est sélectionné, le calque peut être déplacé et animé sur sa position comme d'habitude, mais sinon il restera contraint sur le calque choisi (malheureusement ce paramètre est non animable).\n\nInitial expression by **Felt Tips**\n\nhttps://vimeo.com/104381026","property_types":["2d_spatial"],"tags":["snap","transparent","layer","fixed","static"],"last_update":1590482862497},{"_id":"Snap-zoom-InOut--posZ-1590482479161","code":"var zoom = _slider: zoomDistance: create_; //distance to zoom\r\nvar trans = _slider: transitionTime: create_; //  transition time in frames\r\n\r\ntrans = trans * thisComp.frameDuration;\r\n\r\nvar inTrans  = easeIn(time, inPoint, inPoint + trans, [0,0,zoom], [0,0,0]);\r\nvar outTrans = easeOut(time, outPoint, outPoint - trans*2, [0,0,0], [0,0,zoom]);\r\nvalue+ inTrans - outTrans","name":"Snap zoom InOut (posZ)","documentation":"Permet d'animer la `position Z` automatiquement sur les `calques 3D` concernés en se basant sur le `inPoint` (entrée) et le `outPoint` (sortie) avec une durée de transition personnalisée (`transitionTime`).\n\nTrès pratique (et plus intéressant que le `Snap zoom inOut (scale)` car on peut jouer sur un flou de profondeur de champ en plus) pour l'apparition de pictogrammes, de logos ou de titrages multiples !\n\nInitial expression by **Harry Frank (Graymachine)**\n\nhttps://www.graymachine.com/top-5-effects-expressions/","property_types":["3d_spatial"],"tags":["auto","snap","zoom","dezoom","text","trailer","inOut","Z","position","3D"],"last_update":1590482852684},{"_id":"Snap-zoom-InOut--scale-1590482692054","code":"var snapScale = _slider: snapScale: create_; //percent of scale to zoom\r\nvar trans = _slider: transitionTime: create_; //  transition time in frames\r\n\r\ntrans = trans * thisComp.frameDuration;\r\n\r\ninTrans  = easeOut(time, inPoint, inPoint + trans, [snapScale,snapScale], [0,0]);\r\noutTrans = easeIn(time, outPoint, outPoint - trans, [0,0], [snapScale, snapScale]);\r\nvalue+ inTrans + outTrans","name":"Snap zoom InOut (scale)","documentation":"Permet d'animer l' `échelle` automatiquement sur les calques 2D concernés en se basant sur le `inPoint` (entrée) et le `outPoint` (sortie) avec une durée de transition personnalisée (`transitionTime`).\n\nTrès pratique pour l'apparition de pictogrammes, de logos ou de titrages multiples !\n\nInitial expression by **Harry Frank (Graymachine)**\n\nhttps://www.graymachine.com/top-5-effects-expressions/","property_types":["2d"],"tags":["auto","snap","zoom","dezoom","text","trailer","inOut","scale"],"last_update":1590482842549},{"_id":"Spiral-path--Shape-layer-1590482886386","code":"var vCount = Math.round(_slider: Vertices count: create_) ;\r\nvar initialRadius = _slider: Initial radius: create_;\r\nvar spiralRadius = _slider: Final radius: create_;\r\nvar O = _slider: Vertices spacing: create_/100;\r\nvar centerP = _ point: Center offset: create _; // [0,0] for a shape layer ; = anchorPoint for a mask\r\n\r\n\r\nvar origPath = thisProperty; \r\nvar origPoints = []; \r\nvar origInTang = []; \r\nvar origOutTang = []; \r\n\r\n\r\nfor (var i = 0; i < vCount ; i++){ \r\n        origPoints[i] = centerP+[Math.sin(i*O)*((spiralRadius*i/vCount)+(initialRadius*(vCount-i)/vCount)),Math.cos(i*O)*((spiralRadius*i/vCount)+(initialRadius*(vCount-i)/vCount))];  \r\n    }\r\ncreatePath(origPoints,origInTang,origOutTang,origPath.isClosed());\r\n\r\n","name":"Spiral path (Shape layer)","documentation":"Permet de créer une spirale vectorielle paramétrique via la propriété `tracé` d'un `calque de forme`, conseillé car la spirale sera alors centrée ; il est toutefois possible d'appliquer aussi cette expression sur le `tracé d'un masque`, sachant qu'elle aura son origine dans le coin en haut à gauche, pour l'utiliser par exemple avec le plugin 3D Stroke ou l'extruder dans Element 3D (on pourra néanmoins retoucher la position de son centre avec `Center offset`).\n\nChoisi idéalement un tracé réalisé avec le mode `rotobézier` ou en mode bézier sans tangentes mais en ajoutant un `arrondir les sommets` pour une spirale plus lisse.\n\nLe nombre de tours peut être déterminé en jouant sur les sliders `Vertices spacing` et `Vertices count`, mais attention de ne pas pousser les paramètres trop loin car plus de points feront ramer inévitablement la machine !\n\nInitial expression by **Matthieu Fremeaux (aka FREMOX)**","tags":["path","spiral","helix","vertex","spline","fremox"],"last_update":1590483548236},{"_id":"Squash-Stretch-byTarget-R-1572885529094","code":"var a = thisLayer.toComp(anchorPoint);\r\nif (effect(\"Target Point (Yes) or Layer (No) ?\")(1) == 1) {\r\n\tvar b = effect(\"Target Point\")(1) + 0.0001;\r\n} else {\r\n\tvar b = effect(\"External Target Layer\")(1).toComp(effect(\"External Target Layer\")(1).anchorPoint) + 0.0001;\r\n}\r\nvar V = sub(b, a);\r\nradiansToDegrees(Math.atan2(V[1], V[0])) + 90;","name":"Squash&stretch byTarget R","documentation":"L'expression est à appliquer sur la propriété `rotation` d'un `calque de forme` dans lequel le graphisme complet a été **groupé** au préalable, et dans le quel **la position de ce groupe a été adaptée sur la verticale de manière à ce que le design \"repose\" sur son bord inférieur, sa base, au niveau du point d'ancrage du calque**.\n\nPermet de cibler (pointer) le calque soit vers le point d'effet appelé `Target point`, soit vers un calque extérieur déterminé par le paramètre `External Target Layer` (en choisissant de se baser sur l'un ou l'autre grâce à la case à cocher `Target Point (Yes) or Layer (No) ?`. Il faut alors dans les deux cas placer le calque ou le point d'effet au sommet (sur le bord supérieur) du design, puis les animer l'un ou l'autre pour voir l'effet.\n\nOn ne re-créé pas ici les contrôleurs car cette expression est censée avoir été appliquée APRÈS celle pour le Scale (expression nommée Squash&Stretch byTarget S` ) qui aura déjà appliquée la case à cocher, le point d'effet et la liste déroulante pour choisir le calque (ces paramètres sont identiques pour les 2 expressions).\n\ninitial expression by **Matthieu Robert (aka Freelance Saucisse)** \n\nhttp://lefreelancesaucisse.blogspot.com/search?q=toujours+%C3%A0+la+hauteur\n\nand adapted by **Matthieu Fremeaux (aka Fremox)**\n\n","property_types":["1d"],"tags":["auto","lookAt","target","cible","orientation","squash","stretch"],"last_update":1586262817665},{"_id":"Squash-stretch-by-Target--S-1572884906165","code":"var L = _layer: External Target Layer: create_;\r\n\r\nif (_ checkbox: Target Point(Yes) or Layer(No) ? : create_ == 1) {\r\n\tvar poslook = _point: Target Point: create_ + 0.0001;\r\n} else {\r\n\tvar poslook = L.toComp(L.anchorPoint) + 0.0001;\r\n}\r\n\r\nvar pos = thisLayer.toComp(anchorPoint);\r\nvar dist = length(pos, poslook);\r\n\r\nvar y = scale[1] + (dist / _slider: Estimated rest Length: create_) * 100 - 100;\r\nvar x = scale[1] * scale[0] / y;\r\n\r\n[x, y]","name":"Squash&stretch byTarget S","documentation":"L'expression est à appliquer sur la propriété `échelle` d'un `calque de forme` dans lequel le graphisme complet a été **groupé** au préalable, et dans le quel **la position de ce groupe a été adaptée sur la verticale de manière à ce que le design \"repose\" sur son bord inférieur, sa base, au niveau du point d'ancrage du calque**.\n\nPermet de compresser ce calque entier (`squash`) et de l'étirer (`stretch`) automatiquement sur son échelle en fonction de l'éloignement du bord inférieur par rapport à soit le point d'effet appelé `Target point`, soit à un calque extérieur déterminé par le paramètre `External Target Layer` (en choisissant de se baser sur l'un ou l'autre grâce à la case à cocher `Target Point (Yes) or Layer (No) ?`. Il faut alors dans les deux cas placer le calque ou le point d'effet au sommet (sur le bord supérieur) du design, puis les animer l'un ou l'autre pour voir l'effet.\n\nL'échelle va s'adapter aussi de manière à ce que l'aire du calque une fois déformé reste consistante (comme dans un vrai squash & stretch), à condition que le paramètre `Estimated rest Length`ait été changé (différent de 0 sinon il y aura une erreur d'expression) pour correspondre à la taille estimée de l'objet non déformé.\n\ninitial expression by **Matthieu Robert (aka Freelance Saucisse)** \n\nhttp://lefreelancesaucisse.blogspot.com/search?q=toujours+%C3%A0+la+hauteur\n\nand adapted by **Matthieu Fremeaux (aka Fremox)**\n\n","property_types":["2d"],"tags":["auto","squash","stretch","area","scale","maintain","etire","compresse"],"last_update":1572886244398},{"_id":"Text-Clock-Countdown-1590483753807","code":"var rate = _slider: rate: create_; //vitesse du compte ou décompte : -1 pour un décompte, 1 pour un compte\r\nvar clockStart = _slider: clockStart: create_; //la valeur de temps final voulue\r\n \r\nfunction padZero(n){\r\n  if (n < 10) return \"0\" + n else return \"\" + n\r\n}\r\n \r\nvar clockTime = clockStart + rate*(time - inPoint);\r\n \r\nif (clockTime < 0){\r\n  var sign = \"-\";\r\n  clockTime = -clockTime;\r\n}else{\r\n  var sign = \"\";\r\n}\r\n \r\nvar t = Math.floor(clockTime);\r\nvar hr = Math.floor(t/3600);\r\nvar min = Math.floor((t%3600)/60);\r\nvar sec = Math.floor(t%60);\r\nvar ms = clockTime.toFixed(3).substr(-3);\r\nsign + padZero(hr) + \":\" + padZero(min) + \":\" + padZero(sec) + \".\" + ms","name":"Text Clock Countdown","documentation":"Permet de créer facilement un \"décompte\" dans la propriété `sourceText` d'un calque de texte (plus facile d'accès et plus souple pour la mise en forme et l'animation que l'effet `Nombre`).\n\nPour un décompte, changer la valeur de `clockStart` pour contrôler le `timecode` à partir duquel le chrono commence à descendre.\n\nIl suffit de changer la valeur -1 en 1 dans le curseur `rate` pour inverser le timing du décompte (si positif, le temps évoluera en augmentant ; on peut également mettre 0.5 pour ralentir le temps normal, ou 2 pour doubler la vitesse...)\n\nInitial expression by **Dan EBBERTS**\n\nhttp://www.motionscript.com/design-guide/up-down-clock.html","tags":["text","clock","horloge","timer","DAN EBBERTS","chrono"],"last_update":1590483986366},{"_id":"Text-bloc-Pos--rectShape-1572886548493","code":"try {\r\n\tw = parent.sourceRectAtTime(effect(\"atTime\")(1)).width / 2;\r\n\th = parent.sourceRectAtTime(effect(\"atTime\")(1)).height / 2;\r\n\tl = parent.sourceRectAtTime(effect(\"atTime\")(1)).left;\r\n\tt = parent.sourceRectAtTime(effect(\"atTime\")(1)).top;\r\n\t[w + l, h + t] + [effect(\"offset X\")(1), effect(\"offset Y\")(1)];\r\n} catch (e) {\r\n\tvalue + [effect(\"offset X\")(1), effect(\"offset Y\")(1)];\r\n};","name":"Text bloc Pos (rectShape)","documentation":"À utiliser dans la `position` du `rectangle` en `calque de forme`, parenté au calque de texte auquel on veut qu'il s'adapte. Cette expression vient en support de l'autre expression pour calculer la taille, et permet de bien positionner le bloc rectangulaire sur le parent (l'usage courant étant un calque de texte), c'est pourquoi il est inutile ici de recréer dynamiquement les controleurs puisqu'ils sont censés avoir déjà été appliqués.\n\nBien veiller ensuite à réinitialiser le `Transform>Position` de ce calque vectoriel à [0,0] pour bien placer le bloc correctement par rapport au parent (on peut même le taper en expression pour qu'il se recale automatiquement sur n'importe quel nouveau calque parent).\n\ninitial expression by **Jake in Motion**\n\nhttps://www.youtube.com/watch?v=CVliDoNgoCg","tags":["synthe","text","bloc"],"last_update":1572886790450},{"_id":"Text-clock-countdown-1570719926590","code":"rate = _ slider: rate: create _;;\r\nclockStart = _ slider: clockStart: create _;;\r\n\r\nfunction padZero(n) {\r\n\tif (n < 10) return \"0\" + n\r\n\telse return \"\" + n\r\n}\r\n\r\nclockTime = clockStart + rate * (time - inPoint);\r\n\r\nif (clockTime < 0) {\r\n\tsign = \"-\";\r\n\tclockTime = -clockTime;\r\n} else {\r\n\tsign = \"\";\r\n}\r\n\r\nt = Math.floor(clockTime);\r\nhr = Math.floor(t / 3600);\r\nmin = Math.floor((t % 3600) / 60);\r\nsec = Math.floor(t % 60);\r\nms = clockTime.toFixed(3).substr(-3);\r\nsign + padZero(hr) + \":\" + padZero(min) + \":\" + padZero(sec) + \".\" + ms","name":"Text clock countdown","documentation":"Permet de créer facilement un \"décompte\" dans le sourceText d'un calque de texte (plus facile d'accès et plus souple pour la mise en forme et l'animation que l'effet \"Nombre\").\n\nPour un décompte, changer la valeur de `clockStart` pour controler le timecode à partir duquel le chrono commence à descendre.\n\nIl suffit de changer la valeur -1 en 1 dans le curseur `rate` pour inverser le timing du décompte (si positif, le temps évoluera en augmentant ; on peut également mettre 0.5 pour ralentir le temps normal, ou 2 pour doubler la vitesse...)\n\nInitial expression by **DAN EBBERTS**\n\n<http://www.motionscript.com/design-guide/up-down-clock.html>","property_types":["text_document"],"tags":["time remap","countdown","chrono","clock","DAN EBBERTS"],"last_update":1570721367274},{"_id":"Text-sequential-overshoot--inPoint-1590484124897","code":"var freq = _slider: freq: create_;\r\nvar decay = _slider: decay: create_;\r\nvar delay = _slider: delay: create_;\r\nvar dur = _slider: dur: create_;\r\n\r\nvar myDelay = (textIndex-1)*delay;\r\nvar t = time - (inPoint + myDelay);\r\nvar startVal = 100;\r\nvar endVal = 0;\r\n\r\nif(t < dur){\r\n  linear(t,0,dur,startVal,endVal);\r\n}else{\r\n  var amp = (endVal - startVal)/dur;\r\n  var w = freq*Math.PI*2;\r\n  endVal + amp*(Math.sin(t*w)/Math.exp(decay*t)/w);\r\n}","name":"Text sequential overshoot (inPoint)","documentation":"A appliquer dans la propriété `valeur` d'un sélecteur d'animation de texte de type `expression`.\n\nPermet de décaler l'animation d'un texte lettre par lettre, mot par mot ou ligne par ligne (suivant les réglages avancés du sélecteur) avec un joli effet élastique en plus.\n\nLe décalage ainsi que l'effet élastique se gèrent directement via les différents contrôleurs appliqués sur le calque de texte, tandis que le déclenchement de l'animation dépend du `inPoint` du calque, pendant une durée de transition appelée `dur`.","tags":["text","sequential","overshoot","bounce","elastic","spring","inPoint","auto","delay"],"last_update":1590484615285},{"_id":"Text-sequential-overshoot--keyframed-1590484633069","code":"var freq = _slider: freq: create_;\r\nvar decay = _slider: decay: create_;\r\nvar delay = _slider: delay: create_;\r\nvar bounceCase = _ checkbox: bounceEffect: create_;\r\n\r\nvar n = 0; \r\nif (numKeys > 0){ \r\n  n = nearestKey(time-delay).index; \r\n  if (key(n).time > time) n--; \r\n} \r\nif (n == 0){ \r\n  var t = 0; \r\n}else{ \r\n  var t = time - key(n).time - delay; \r\n} \r\n \r\nif (n > 0){ \r\n  var v = velocityAtTime(key(n).time -.001); \r\nif(bounceCase==0){\r\nvalueAtTime(time-delay)/2 + v*Math.sin(freq*t*2*Math.PI)/Math.exp(decay*t);\r\n}else{\r\nvalueAtTime(time-delay)/2 + v*-Math.abs(Math.sin(freq*t*2*Math.PI))/Math.exp(decay*t); \r\n}\r\n}else{ \r\n  1/2; \r\n}","name":"Text sequential overshoot (keyframed)","documentation":"A appliquer dans la propriété `valeur` d'un sélecteur d'animation de texte de type `expression`.\n\nPermet de décaler l'animation de texte lettre par lettre, mot par mot ou ligne par ligne (suivant les réglages avancés du sélecteur) avec un joli effet élastique en plus.\n\nLe décalage ainsi que l'effet élastique se gèrent directement via les différents contrôleurs appliqués sur le calque de texte.\n\nATTENTION, ça ne fonctionnera correctement qu'à condition que cette même propriété `Valeur` soit animée avec des images clés, avec `lissage de vitesse` (avec F9 par exemple) !","tags":["text","sequential","overshoot","bounce","elastic","spring","inPoint","auto","delay"],"last_update":1590484765238},{"_id":"Trigger-Anim-at-Marker-1590484782761","code":"var n=0;\r\nif(marker.numKeys>0){\r\n  n=marker.nearestKey(time).index;\r\n  if(marker.key(n).time>time){\r\n    n--;\r\n  }\r\n  if(n==0){\r\n    value;\r\n  }else{\r\n    t=time-marker.key(n).time; //time since marker\r\n  }\r\n}else{\r\nvalue;\r\n}","name":"Trigger Anim at Marker","documentation":"Expression à appliquer sur la propriété `Remappage temporel` (pour une précomp avec une animation à l'intérieur commençant au début)\n\nPermet de déclencher une `animation pré-composée` (par exemple un effet de clic pour une souris, avec possibilité d'ajouter un son dedans) à chaque nouveau `marqueur` créé sur la précomp (il suffit de cliquer sur le signe * du clavier avec le calque de la précomp sélectionné à chaque fois qu'on veut créer un marqueur à l'instant T).\n\nInitial expression by **Jr Canest**\n\nhttps://docs.google.com/spreadsheets/d/1a3ArTUHAJwVi-ObZofvz6IfrKbSGSENlaTIRTs8pAJU/edit#gid=0","property_types":["other"],"tags":["trigger","marker","time remap"],"last_update":1590484910013},{"_id":"Trigger-Anim-at-Marker-comments-1590484923855","code":"var action = source.layer(\"action\");\r\nvar n = 0;\r\nif (marker.numKeys > 0){\r\n  n = marker.nearestKey(time).index;\r\n  if (marker.key(n).time > time){\r\n    n--;\r\n  }\r\n}\r\nif (n == 0){\r\n  0\r\n}else{\r\n  var m = marker.key(n);\r\n  var myComment = m.comment;\r\n  var t = time - m.time;\r\n  try{\r\n    var actMarker = action.marker.key(myComment);\r\n    if (action.marker.numKeys > actMarker.index){\r\n      var tMax = action.marker.key(actMarker.index + 1).time - actMarker.time;\r\n    }else{\r\n      var tMax = action.outPoint - actMarker.time;\r\n    }\r\n    t = Math.min(t, tMax);\r\n    actMarker.time + t;\r\n  }catch (err){\r\n    0\r\n  }\r\n}","name":"Trigger Anim at Marker comments","documentation":"Permet d'appeler des animations pré-composées (par exemple des parties de visages animées, des phonèmes pour une bouche, des états de curseurs...) via les `commentaires de marqueurs`.\n\nPour que ça fonctionne, à l'intérieur de la pré-composition qui reçoit l'expression sur son `Remappage temporel`, il faut créér un `calque - Null` par exemple - appelé \"action\", sur lequel on créé autant de `marqueurs avec commentaires` (double-clic gauche sur les marqueurs créés puis on entre le mot clé ou la lettre qu'on veut dans \"Commentaire\") que l'on veut pouvoir les appeler ensuite.\n\nIl suffit alors, une fois l'expression mise sur le Remappage temporel de la précomp, de `créér les mêmes marqueurs sur la précomp avec les mêmes commentaires`, mais à des instants T personnalisés.\n\nInitial expression by **Dan EBBERTS**\n\nhttp://www.motionscript.com/design-guide/marker-sync.html","property_types":["other"],"tags":["trigger","marker","time remap","comment"],"last_update":1590485060789},{"_id":"Trigger-anim-by-markers-comment-1570693725957","code":"action = source.layer(\"action\");\r\nn = 0;\r\nif (marker.numKeys > 0) {\r\n\tn = marker.nearestKey(time).index;\r\n\tif (marker.key(n).time > time) {\r\n\t\tn--;\r\n\t}\r\n}\r\nif (n == 0) {\r\n\t0\r\n} else {\r\n\tm = marker.key(n);\r\n\tmyComment = m.comment;\r\n\tt = time - m.time;\r\n\ttry {\r\n\t\tactMarker = action.marker.key(myComment);\r\n\t\tif (action.marker.numKeys > actMarker.index) {\r\n\t\t\ttMax = action.marker.key(actMarker.index + 1).time - actMarker.time;\r\n\t\t} else {\r\n\t\t\ttMax = action.outPoint - actMarker.time;\r\n\t\t}\r\n\t\tt = Math.min(t, tMax);\r\n\t\tactMarker.time + t;\r\n\t} catch (err) {\r\n\t\t0\r\n\t}\r\n}","name":"Trigger anim at markers C","documentation":"Permet d'appeler des animations précomposées (par exemple des parties de visages animées, des phonèmes pour une bouche, des états de curseurs...) via les commentaires de marqueurs.\n\nPour que ça fonctionne, à l'intérieur de la précomposition qui reçoit l'expression sur son `remappage temporel`, il faut créér un calque Nul appelé `action`, sur lequel on créé autant de marqueurs avec commentaires (double-clic gauche sur les marqueurs créés puis on entre le mot clé ou la lettre qu'on veut dans \"Commentaire\") que l'on veut pouvoir appeler ensuite.\n\nIl suffit alors, une fois l'expression mise sur le remappage temporel de la précomp, de créér les mêmes marqueurs sur la précomp avec les mêmes commentaires, mais à des instants T personnalisés.\n\nInitial expression by **DAN EBBERTS**\n\n<http://www.motionscript.com/design-guide/marker-sync.html>","property_types":["other","1d"],"tags":["trigger","animation","marker","time remap","DAN EBBERTS"],"last_update":1572882681222}]}]